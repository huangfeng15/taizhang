
# 项目采购与成本管理系统 - 监控指标体系设计方案

## 文档信息

**文档版本：** v1.1 (修订版)
**创建日期：** 2025-10-23
**修订日期：** 2025-10-23
**文档类型：** 技术设计文档（功能扩展）
**目标读者：** 开发团队、产品经理

---

## ⚠️ 重要说明

**本设计方案是在现有"项目采购与成本管理系统"基础上增加监控指标功能，而不是创建新的独立系统。**

所有设计都基于以下前提：
- ✅ 复用现有的 Django 项目结构
- ✅ 使用现有的数据模型（[`procurement/`](procurement/), [`contract/`](contract/), [`payment/`](payment/), [`settlement/`](settlement/)）
- ✅ 基于现有的模板系统（[`project/templates/`](project/templates/)）
- ✅ 直接查询现有数据库，不新建业务数据表

---

## 1. 概述

### 1.1 设计目标

基于需求文档增加版和指标体系需求文档，**在现有系统上**增加监控指标体系，包括：

1. **资料归档监控模块**：监控采购、合同、结算资料的归档情况（使用现有 `archive_date` 字段）
2. **数据更新时效性模块**：监控各项目各模块的数据更新状态（使用现有 `updated_at` 字段）
3. **业务数据统计模块**：提供采购、合同、付款、结算的全面统计（实时查询现有数据）
4. **数据齐全性检查模块**：检查必填项的完整性（检查现有模型的关联关系）
5. **报表导出模块**：支持周报、月报、季度报、年报导出（使用已有的 openpyxl）

### 1.2 设计原则

- **最小侵入**：在现有代码基础上扩展，不破坏现有功能
- **组件化**：功能模块化，服务层独立封装
- **可复用**：公共组件和工具函数独立封装
- **可扩展**：预留扩展接口，支持未来功能增加
- **高性能**：使用查询优化，必要时使用缓存

---

## 2. 系统架构设计

### 2.1 整体架构

```
项目根目录/
├── monitoring/                    # 新增：监控指标模块
│   ├── __init__.py
│   ├── models.py                 # 数据模型（缓存表等）
│   ├── views.py                  # 主视图入口
│   ├── admin.py                  # Admin配置
│   ├── apps.py
│   ├── services/                 # 业务逻辑层
│   │   ├── __init__.py
│   │   ├── archive_service.py   # 归档监控服务
│   │   ├── update_service.py    # 数据更新监控服务
│   │   ├── statistics_service.py # 统计服务
│   │   ├── completeness_service.py # 齐全性检查服务
│   │   └── ranking_service.py   # 业务排名服务
│   ├── utils/                    # 工具函数
│   │   ├── __init__.py
│   │   ├── date_utils.py        # 日期处理工具
│   │   ├── calculation_utils.py # 计算工具
│   │   └── cache_utils.py       # 缓存工具
│   └── migrations/
│
├── reports/                      # 新增：报表生成模块
│   ├── __init__.py
│   ├── views.py                  # 报表视图
│   ├── generators/               # 报表生成器
│   │   ├── __init__.py
│   │   ├── base_generator.py    # 基础生成器
│   │   ├── weekly_generator.py  # 周报生成器
│   │   ├── monthly_generator.py # 月报生成器
│   │   ├── quarterly_generator.py # 季报生成器
│   │   └── annual_generator.py  # 年报生成器
│   ├── exporters/                # 导出器
│   │   ├── __init__.py
│   │   ├── excel_exporter.py    # Excel导出
│   │   ├── pdf_exporter.py      # PDF导出
│   │   └── word_exporter.py     # Word导出
│   └── templates/                # 报表模板
│       ├── weekly_report.html
│       ├── monthly_report.html
│       ├── quarterly_report.html
│       └── annual_report.html
│
├── project/templates/
│   ├── monitoring/               # 监控页面模板
│   │   ├── dashboard.html       # 监控仪表盘
│   │   ├── archive_monitor.html # 归档监控
│   │   ├── update_monitor.html  # 更新监控
│   │   ├── statistics.html      # 统计页面
│   │   ├── completeness.html    # 齐全性检查
│   │   └── ranking.html         # 业务排名
│   ├── reports/                  # 报表页面模板
│   │   ├── report_list.html     # 报表列表
│   │   └── report_preview.html  # 报表预览
│   └── components/
│       ├── charts/               # 图表组件
│       │   ├── pie_chart.html
│       │   ├── bar_chart.html
│       │   ├── line_chart.html
│       │   └── gauge_chart.html
│       ├── tables/               # 表格组件
│       │   ├── data_table.html
│       │   └── ranking_table.html
│       └── widgets/              # 小部件
│           ├── metric_card.html
│           ├── progress_ring.html
│           └── alert_badge.html
│
└── static/
    ├── css/
    │   ├── monitoring.css        # 监控页面样式
    │   └── reports.css           # 报表样式
    └── js/
        ├── monitoring.js         # 监控交互
        ├── charts.js             # 图表库封装
        └── reports.js            # 报表交互
```

### 2.2 模块职责划分

| 层级 | 位置 | 职责 | 说明 |
|------|------|------|------|
| **视图层** | [`project/views.py`](project/views.py) | 监控和报表视图函数 | 扩展现有文件，增加新视图 |
| **服务层** | [`project/services/`](project/services/) | 业务逻辑封装 | 新建目录，实现各类统计和监控逻辑 |
| **工具层** | [`project/utils/`](project/utils/) | 通用工具函数 | 新建目录，封装日期、图表等工具 |
| **模板层** | [`project/templates/monitoring/`](project/templates/monitoring/) | 监控页面模板 | 新建子目录，保持与现有风格一致 |
| **数据层** | 现有模型 | 数据查询 | **只读**，不修改现有模型结构 |

### 2.3 数据依赖关系

**所有监控功能都基于现有数据模型：**

```
监控服务层
    ↓ 查询（只读）
现有数据模型
├── procurement.models.Procurement  # 采购数据
├── contract.models.Contract        # 合同数据
├── payment.models.Payment          # 付款数据
└── settlement.models.Settlement    # 结算数据
```

**关键字段依赖：**
- 归档监控 → `archive_date`, `platform_publicity_date`, `signing_date`
- 更新监控 → `created_at`, `updated_at` (所有模型都有)
- 统计分析 → 各模型的金额、日期、分类字段
- 齐全性检查 → 关联字段（`parent_contract`, `procurement` 等）

---

## 3. 数据模型设计

### 3.1 监控缓存表

为提升性能，创建缓存表存储计算结果：

```python
# monitoring/models.py

from django.db import models
from django.utils import timezone


class MonitoringCache(models.Model):
    """监控数据缓存表"""
    
    cache_key = models.CharField('缓存键', max_length=200, unique=True, db_index=True)
    cache_type = models.CharField('缓存类型', max_length=50, db_index=True,
        choices=[
            ('archive', '归档监控'),
            ('update', '更新监控'),
            ('statistics', '统计数据'),
            ('completeness', '齐全性'),
            ('ranking', '排名')
        ]
    )
    data = models.JSONField('缓存数据')
    expired_at = models.DateTimeField('过期时间', db_index=True)
    created_at = models.DateTimeField('创建时间', auto_now_add=True)
    updated_at = models.DateTimeField('更新时间', auto_now=True)
    
    class Meta:
        verbose_name = '监控缓存'
        verbose_name_plural = '监控缓存'
        ordering = ['-updated_at']


class ReportRecord(models.Model):
    """报表生成记录"""
    
    report_type = models.CharField('报表类型', max_length=20,
        choices=[
            ('weekly', '周报'),
            ('monthly', '月报'),
            ('quarterly', '季报'),
            ('annual', '年报')
        ]
    )
    period_start = models.DateField('统计周期开始')
    period_end = models.DateField('统计周期结束')
    generated_by = models.CharField('生成人', max_length=50)
    file_path = models.CharField('文件路径', max_length=500, blank=True)
    file_format = models.CharField('文件格式', max_length=10,
        choices=[
            ('excel', 'Excel'),
            ('pdf', 'PDF'),
            ('word', 'Word')
        ]
    )
    status = models.CharField('状态', max_length=20,
        choices=[
            ('generating', '生成中'),
            ('completed', '已完成'),
            ('failed', '失败')
        ],
        default='generating'
    )
    created_at = models.DateTimeField('创建时间', auto_now_add=True)
    
    class Meta:
        verbose_name = '报表记录'
        verbose_name_plural = '报表记录'
        ordering = ['-created_at']
```

### 3.2 扩展现有模型

在现有模型中添加必要的字段支持新功能：

```python
# 无需新增字段，利用现有的 created_at 和 updated_at 字段
# 利用现有的 archive_date 字段进行归档监控
```

---

## 4. 服务层设计

### 4.1 归档监控服务

```python
# monitoring/services/archive_service.py

from django.db.models import Count, Q, F
from django.utils import timezone
from datetime import timedelta
from procurement.models import Procurement
from contract.models import Contract
from settlement.models import Settlement


class ArchiveMonitorService:
    """归档监控服务"""
    
    def get_archive_overview(self):
        """获取归档总览数据"""
        return {
            'procurement': self._get_procurement_archive_stats(),
            'contract': self._get_contract_archive_stats(),
            'settlement': self._get_settlement_archive_stats(),
            'overall_rate': self._calculate_overall_rate()
        }
    
    def _get_procurement_archive_stats(self):
        """采购归档统计"""
        total = Procurement.objects.filter(
            platform_publicity_date__isnull=False
        ).count()
        
        archived = Procurement.objects.filter(
            archive_date__isnull=False
        ).count()
        
        # 逾期统计（公示后40天）
        deadline = timezone.now().date() - timedelta(days=40)
        overdue = Procurement.objects.filter(
            platform_publicity_date__lte=deadline,
            archive_date__isnull=True
        ).count()
        
        return {
            'total': total,
            'archived': archived,
            'rate': (archived / total * 100) if total > 0 else 0,
            'overdue': overdue
        }
    
    def _get_contract_archive_stats(self):
        """合同归档统计"""
        # 只统计主合同
        total = Contract.objects.filter(
            contract_type='主合同'
        ).count()
        
        archived = Contract.objects.filter(
            contract_type='主合同',
            archive_date__isnull=False
        ).count()
        
        # 逾期统计（签订后30天）
        deadline = timezone.now().date() - timedelta(days=30)
        overdue = Contract.objects.filter(
            contract_type='主合同',
            signing_date__lte=deadline,
            archive_date__isnull=True
        ).count()
        
        return {
            'total': total,
            'archived': archived,
            'rate': (archived / total * 100) if total > 0 else 0,
            'overdue': overdue
        }
    
    def _get_settlement_archive_stats(self):
        """结算归档统计（待扩展）"""
        # 结算归档日期字段暂未实现
        return {
            'total': 0,
            'archived': 0,
            'rate': 0,
            'overdue': 0,
            'note': '结算归档日期字段待补充'
        }
    
    def _calculate_overall_rate(self):
        """计算总体归档率"""
        # 综合采购和合同的归档率
        pass
    
    def get_overdue_list(self, module=None, severity=None):
        """获取逾期项目列表
        
        Args:
            module: 模块类型 (procurement/contract/settlement)
            severity: 严重程度 (mild/moderate/severe)
        """
        pass
```

### 4.2 数据更新监控服务

> **核心逻辑修订 (2025-10-25):** 根据最新需求，数据更新的准时性判断标准从“最后更新时间” (`updated_at`) 修改为基于“业务事件发生时间”。这要求服务层逻辑进行根本性重构，以准确反映业务的真实时效性。

#### 4.2.1 指标与规则定义

##### 1. 业务事件触发规则
数据更新监控以业务的实际发生为起点。
- **采购模块**: 中标结果公示 (`Procurement.platform_publicity_date`)。
- **合同模块**: 合同签订 (`Contract.signing_date`)。
- **付款模块**: 付款发生 (`Payment.payment_date`)。
- **结算模块**: 结算完成 (`Settlement.settlement_completion_date` - **待补充字段**)。

##### 2. 准时更新规则
- **定义**: 数据在业务发生的 **次月月底前** 完成录入，即视为“准时”。
- **示例**: 1月15日发生的业务，在2月28日（或29日）及之前完成录入，均为准时。3月1日及之后录入，则为“延迟”。

##### 3. 可视化规则
- **无业务发生**: 如果某月没有发生任何业务事件，则该模块在该月状态为“无业务”，在热力图中以灰色单元格表示。
- **混合状态**: 如果某月同一模块下发生多次业务，其中既有准时录入，也有延迟录入，则在热力图中使用“单元格内比例条”进行可视化，直观展示准时与延迟的比例。

#### 4.2.2 核心监控指标 (KPI) 定义
仪表盘顶部应提供全局数据更新状态的宏观视图，包含以下四个核心指标：
1.  **监控中项目总数**: 当前筛选年份下，有业务事件发生的所有项目的总和。
2.  **总体更新准时率**: 在设定的数据边界内（见4.2.4），所有模块的 `准时事件总数 / 业务事件总数`。
3.  **业务事件总数**: 在设定的数据边界内，所有模块发生的业务事件的总和。
4.  **累计延迟事件数**: 在设定的数据边界内，所有模块发生的延迟录入事件的总和。

#### 4.2.3 详细统计数据表
为提供详细、可追溯的量化统计，仪表盘需包含一个详细数据表格，并支持双视图切换。

##### 1. 统计维度
- **按项目统计**: 表格的每一行代表一个项目，用于评估项目整体的数据管理健康度。
- **按人员统计**: 表格的每一行代表一个数据录入人员（经办人），用于评估团队成员的工作绩效。

##### 2. 指标列
无论是按项目还是按人员统计，表格均需为 **采购、合同、付款、结算** 以及 **总计** 提供以下四列数据：
- **准时数**: 准时录入的事件数量。
- **延迟数**: 延迟录入的事件数量。
- **总数**: 事件总数（准时数 + 延迟数）。
- **准时率**: `准时数 / 总数`，以百分比形式展示。

##### 3. 准时率色彩预警
为快速识别问题，“准时率”单元格需根据数值进行色彩编码：
- **>= 90%**: 绿色 (优秀)
- **60% - 90%**: 橙色 (平均)
- **< 60%**: 红色 (警告)

#### 4.2.4 数据边界与过滤条件
为确保统计口径的清晰与准确，必须提供并明确以下数据边界条件：

1.  **统计年度独立性**: 所有准时率相关的计算（包括KPI、热力图、详细统计表）都严格以用户在页面上选择的 **“统计年份”** 为独立单元。例如，选择“2025年”，则只统计在2025年1月1日至12月31日之间发生的业务事件。

2.  **监控起始日期**:
    - **功能**: 页面需提供一个 **“监控起始日期”** 的日期选择器。
    - **核心规则**: 所有业务发生时间早于此“起始日期”的历史数据，将 **被完全排除在准时率的计算之外**。
    - **设计目的**: 此功能用于完美解决因历史数据补录而导致的“伪延迟”报警问题。用户可将此日期设置为系统正式启用日期，从而确保监控数据的纯净性。

#### 4.2.5 服务层实现 (伪代码)

原有的 `UpdateMonitorService` 需要重构，以支持按月度、按事件、并结合数据边界进行检查。

```python
# monitoring/services/update_service.py (重构后)

from django.db.models import Count
from django.db.models.functions import TruncMonth
from project.models import Project
from procurement.models import Procurement
from contract.models import Contract
from payment.models import Payment
from settlement.models import Settlement

class UpdateMonitorService:
    """数据更新监控服务 (事件驱动模型)"""

    def get_monitoring_data(self, year, start_date):
        """
        获取指定年份和起始日期下的所有监控数据。
        
        Args:
            year (int): 统计年份
            start_date (date): 监控起始日期
            
        Returns:
            一个包含热力图数据和详细统计数据的字典。
        """
        projects = Project.objects.filter(start_date__year__lte=year)
        
        # 1. 计算所有符合条件的事件
        all_events = self._collect_all_events(projects, year, start_date)
        
        # 2. 基于事件生成热力图数据
        heatmap_data = self._generate_heatmap_data(all_events)
        
        # 3. 基于事件生成详细统计数据
        detailed_stats = self._generate_detailed_stats(all_events)
        
        return {
            'heatmap': heatmap_data,
            'statistics': detailed_stats
        }

    def _collect_all_events(self, projects, year, start_date):
        """收集所有在边界条件内的业务事件"""
        events = []
        
        # 示例：收集采购事件
        procurements = Procurement.objects.filter(
            project__in=projects,
            platform_publicity_date__year=year,
            platform_publicity_date__gte=start_date
        )
        for proc in procurements:
            events.append({
                'project_id': proc.project.id,
                'project_name': proc.project.project_name,
                'handler': proc.created_by.username, # 假设有经办人字段
                'module': 'procurement',
                'event_date': proc.platform_publicity_date,
                'update_date': proc.updated_at.date()
            })
            
        # ... 此处省略 contract, payment, settlement 的事件收集逻辑 ...
        
        return events

    def _generate_heatmap_data(self, events):
        """根据事件列表生成热力图所需的数据结构"""
        # ... 伪代码: 遍历 events，按 project_id 和 module 分组，再按月份聚合 ...
        pass

    def _generate_detailed_stats(self, events):
        """根据事件列表生成详细统计数据"""
        stats = {
            'by_project': {},
            'by_person': {}
        }
        
        # ... 伪代码: 遍历 events，同时填充 by_project 和 by_person 字典 ...
        # ... 计算每个单元格的 timely, delayed, total ...
        
        return stats
```

### 4.3 统计服务

```python
# monitoring/services/statistics_service.py

from django.db.models import Sum, Count, Avg, Q, F
from django.db.models.functions import TruncYear, TruncMonth
from decimal import Decimal
from procurement.models import Procurement
from contract.models import Contract
from payment.models import Payment
from settlement.models import Settlement


class StatisticsService:
    """业务数据统计服务"""
    
    def get_procurement_statistics(self, year=None, project_id=None):
        """采购统计"""
        queryset = Procurement.objects.all()
        
        if year:
            queryset = queryset.filter(
                platform_publicity_date__year=year
            )
        
        if project_id:
            queryset = queryset.filter(project_id=project_id)
        
        return {
            'total_count': queryset.count(),
            'total_budget': queryset.aggregate(Sum('budget_amount'))['budget_amount__sum'] or 0,
            'total_winning': queryset.aggregate(Sum('winning_amount'))['winning_amount__sum'] or 0,
            'by_method': self._group_by_procurement_method(queryset),
            'by_duration': self._analyze_procurement_duration(queryset),
            'by_plan_deviation': self._analyze_plan_deviation(queryset)
        }
    
    def _group_by_procurement_method(self, queryset):
        """按采购方式分组统计"""
        result = queryset.values('procurement_method').annotate(
            count=Count('id'),
            total_amount=Sum('winning_amount')
        )
        
        total_count = queryset.count()
        total_amount = queryset.aggregate(Sum('winning_amount'))['winning_amount__sum'] or 0
        
        for item in result:
            item['count_ratio'] = (item['count'] / total_count * 100) if total_count > 0 else 0
            item['amount_ratio'] = (item['total_amount'] / total_amount * 100) if total_amount > 0 else 0
        
        return list(result)
    
    def _analyze_procurement_duration(self, queryset):
        """采购周期分析"""
        # 计算采购耗时 = 平台公示完成日期 - 需求书审批完成日期
        durations = []
        for proc in queryset.filter(
            platform_publicity_date__isnull=False,
            requirement_approval_date__isnull=False
        ):
            duration = (proc.platform_publicity_date - proc.requirement_approval_date).days
            durations.append({
                'procurement_code': proc.procurement_code,
                'procurement_name': proc.procurement_project_name,
                'procurement_method': proc.procurement_method,
                'duration': duration
            })
        
        return durations
    
    def _analyze_plan_deviation(self, queryset):
        """采购计划偏差分析"""
        deviations = []
        for proc in queryset.filter(
            platform_publicity_date__isnull=False,
            planned_completion_date__isnull=False
        ):
            deviation = (proc.platform_publicity_date - proc.planned_completion_date).days
            deviations.append({
                'procurement_code': proc.procurement_code,
                'procurement_name': proc.procurement_project_name,
                'planned_date': proc.planned_completion_date,
                'actual_date': proc.platform_publicity_date,
                'deviation_days': deviation,
                'status': 'on_time' if deviation <= 0 else ('mild' if deviation <= 7 else ('moderate' if deviation <= 30 else 'severe'))
            })
        
        return deviations
    
    def get_contract_statistics(self, year=None, project_id=None):
        """合同统计"""
        queryset = Contract.objects.all()
        
        if year:
            queryset = queryset.filter(signing_date__year=year)
        
        if project_id:
            queryset = queryset.filter(project_id=project_id)
        
        return {
            'total_count': queryset.count(),
            'total_amount': queryset.aggregate(Sum('contract_amount'))['contract_amount__sum'] or 0,
            'by_type': self._group_by_contract_type(queryset),
            'by_source': self._group_by_contract_source(queryset)
        }
    
    def _group_by_contract_type(self, queryset):
        """按合同类型分组"""
        return list(queryset.values('contract_type').annotate(
            count=Count('id'),
            total_amount=Sum('contract_amount')
        ))
    
    def _group_by_contract_source(self, queryset):
        """按合同来源分组"""
        return list(queryset.values('contract_source').annotate(
            count=Count('id'),
            total_amount=Sum('contract_amount')
        ))
    
    def get_payment_statistics(self, year=None, project_id=None):
        """付款统计"""
        queryset = Payment.objects.all()
        
        if year:
            queryset = queryset.filter(payment_date__year=year)
        
        if project_id:
            queryset = queryset.filter(contract__project_id=project_id)
        
        return {
            'total_count': queryset.count(),
            'total_amount': queryset.aggregate(Sum('payment_amount'))['payment_amount__sum'] or 0,
            'avg_amount': queryset.aggregate(Avg('payment_amount'))['payment_amount__avg'] or 0,
            'top_projects': self._get_top_payment_projects(queryset),
            'remaining_payments': self._calculate_remaining_payments()
        }
    
    def _get_top_payment_projects(self, queryset, limit=10):
        """获取付款金额最大的项目TOP"""
        return list(queryset.values(
            'contract__project__project_code',
            'contract__project__project_name'
        ).annotate(
            total_payment=Sum('payment_amount'),
            payment_count=Count('id')
        ).order_by('-total_payment')[:limit])
    
    def _calculate_remaining_payments(self):
        """计算预计剩余支付金额"""
        # 按结算价计算（无结算价按合同价）
        projects = []
        from project.models import Project
        
        for project in Project.objects.all():
            total_contract_settlement = Decimal('0')
            total_payment = Decimal('0')
            
            for contract in project.contracts.filter(contract_type='主合同'):
                # 获取结算价或合同价
                try:
                    settlement = contract.settlement
                    contract_value = settlement.final_amount
                    source = 'settlement'
                except:
                    contract_value = contract.contract_amount
                    source = 'contract'
                
                total_contract_settlement += contract_value
                
                # 累计付款
                contract_payment = contract.payments.aggregate(
                    Sum('payment_amount')
                )['payment_amount__sum'] or Decimal('0')
                total_payment += contract_payment
            
            remaining = total_contract_settlement - total_payment
            
            projects.append({
                'project_code': project.project_code,
                'project_name': project.project_name,
                'contract_settlement_value': total_contract_settlement,
                'total_payment': total_payment,
                'remaining': remaining,
                'payment_rate': (total_payment / total_contract_settlement * 100) if total_contract_settlement > 0 else 0
            })
        
        return projects
    
    def get_settlement_statistics(self, project_id=None):
        """结算统计"""
        queryset = Settlement.objects.all()
        
        if project_id:
            queryset = queryset.filter(main_contract__project_id=project_id)
        
        settled_count = queryset.count()
        settled_amount = queryset.aggregate(Sum('final_amount'))['final_amount__sum'] or 0
        
        # 未结算统计
        unsettled_contracts = Contract.objects.filter(
            contract_type='主合同',
            settlement__isnull=True
        )
        unsettled_count = unsettled_contracts.count()
        unsettled_amount = unsettled_contracts.aggregate(
            Sum('contract_amount')
        )['contract_amount__sum'] or 0
        
        return {
            'settled_count': settled_count,
            'settled_amount': settled_amount,
            'unsettled_count': unsettled_count,
            'unsettled_amount': unsettled_amount,
            'settlement_rate': (settled_count / (settled_count + unsettled_count) * 100) if (settled_count + unsettled_count) > 0 else 0,
            'deviation_analysis': self._analyze_settlement_deviation(queryset)
        }
    
    def _analyze_settlement_deviation(self, queryset):
        """结算价与合同价偏差分析"""
        deviations = []
        for settlement in queryset:
            contract = settlement.main_contract
            deviation = settlement.final_amount - contract.contract_amount
            deviation_rate = (deviation / contract.contract_amount * 100) if contract.contract_amount > 0 else 0
            
            deviations.append({
                'contract_code': contract.contract_code,
                'contract_name': contract.contract_name,
                'contract_amount': contract.contract_amount,
                'settlement_amount': settlement.final_amount,
                'deviation': deviation,
                'deviation_rate': deviation_rate
            })
        
        return deviations
```

### 4.4 数据齐全性服务

```python
# monitoring/services/completeness_service.py

from procurement.models import Procurement
from contract.models import Contract
from payment.models import Payment
from settlement.models import Settlement


class CompletenessService:
    """数据齐全性检查服务"""
    
    def check_all_modules(self, project_id=None):
        """检查所有模块的数据齐全性"""
        return {
            'procurement': self.check_procurement_completeness(project_id),
            'contract': self.check_contract_completeness(project_id),
            'payment': self.check_payment_completeness(project_id),
            'settlement': self.check_settlement_completeness(project_id),
            'overall': self._calculate_overall_completeness(project_id)
        }
    
    def check_procurement_completeness(self, project_id=None):
        """检查采购数据齐全性
        
        注意：采购模块所有核心字段在导入时已强制要求，
        因此这里主要检查可选但重要的关联字段
        """
        queryset = Procurement.objects.all()
        if project_id:
            queryset = queryset.filter(project_id=project_id)
        
        total = queryset.count()
        # 由于所有必填项都在导入时验证，这里齐全率为100%
        complete = total
        
        return {
            'total': total,
            'complete': complete,
            'rate': 100.0,
            'missing_records': [],
            'note': '采购模块核心字段在导入时已强制验证'
        }
    
    def check_contract_completeness(self, project_id=None):
        """检查合同数据齐全性
        
        需要检查的关联字段：
        - 补充协议必须关联主合同
        - 采购合同必须关联采购项目
        """
        queryset = Contract.objects.all()
        if project_id:
            queryset = queryset.filter(project_id=project_id)
        
        total = queryset.count()
        missing_records = []
        
        # 检查补充协议的主合同关联
        supplement_without_parent = queryset.filter(
            contract_type='补充协议',
            parent_contract__isnull=True
        )
        
        for contract in supplement_without_parent:
            missing_records.append({
                'contract_code': contract.contract_code,
                'contract_name': contract.contract_name,
                'missing_field': '关联主合同',
                'reason': '补充协议必须关联主合同'
            })
        
        # 检查采购合同的采购关联
        procurement_contract_without_link = queryset.filter(
            contract_source='采购合同',
            procurement__isnull=True
        )
        
        for contract in procurement_contract_without_link:
            missing_records.append({
                'contract_code': contract.contract_code,
                'contract_name': contract.contract_name,
                'missing_field': '关联采购',
                'reason': '采购合同必须关联采购项目'
            })
        
        incomplete = len(missing_records)
        complete = total - incomplete
        
        return {
            'total': total,
            'complete': complete,
            'incomplete': incomplete,
            'rate': (complete / total * 100) if total > 0 else 0,
            'missing_records': missing_records
        }
    
    def check_payment_completeness(self, project_id=None):
        """检查付款数据齐全性"""
        queryset = Payment.objects.all()
        if project_id:
            queryset = queryset.filter(contract__project
progress-label {
    font-size: 12px;
    color: #666;
}
</style>
```

---

## 7. 视图层设计

### 7.1 监控仪表盘视图

```python
# monitoring/views.py

from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from monitoring.services.archive_service import ArchiveMonitorService
from monitoring.services.update_service import UpdateMonitorService
from monitoring.services.statistics_service import StatisticsService
from monitoring.services.completeness_service import CompletenessService
from monitoring.services.ranking_service import RankingService


@login_required
def dashboard(request):
    """监控仪表盘主页"""
    # 获取各类监控数据
    archive_service = ArchiveMonitorService()
    update_service = UpdateMonitorService()
    stats_service = StatisticsService()
    
    context = {
        'archive_overview': archive_service.get_archive_overview(),
        'update_alerts': update_service.get_project_update_status()[:10],  # 前10条预警
        'procurement_stats': stats_service.get_procurement_statistics(),
        'contract_stats': stats_service.get_contract_statistics(),
        'payment_stats': stats_service.get_payment_statistics(),
    }
    
    return render(request, 'monitoring/dashboard.html', context)


@login_required
def archive_monitor(request):
    """归档监控页面"""
    archive_service = ArchiveMonitorService()
    
    # 获取筛选参数
    module = request.GET.get('module')
    severity = request.GET.get('severity')
    
    context = {
        'overview': archive_service.get_archive_overview(),
        'overdue_list': archive_service.get_overdue_list(module, severity),
    }
    
    return render(request, 'monitoring/archive_monitor.html', context)


@login_required
def update_monitor(request):
    """数据更新监控页面"""
    update_service = UpdateMonitorService()
    
    # 获取筛选参数
    project_id = request.GET.get('project_id')
    alert_level = request.GET.get('alert_level')
    
    status_list = update_service.get_project_update_status(project_id)
    
    # 按预警级别筛选
    if alert_level:
        status_list = [s for s in status_list if s['alert_level'] == alert_level]
    
    context = {
        'status_list': status_list,
    }
    
    return render(request, 'monitoring/update_monitor.html', context)


@login_required
def statistics_view(request):
    """统计页面"""
    stats_service = StatisticsService()
    
    # 获取年份参数
    year = request.GET.get('year')
    if year:
        year = int(year)
    
    context = {
        'procurement_stats': stats_service.get_procurement_statistics(year=year),
        'contract_stats': stats_service.get_contract_statistics(year=year),
        'payment_stats': stats_service.get_payment_statistics(year=year),
        'settlement_stats': stats_service.get_settlement_statistics(),
        'selected_year': year,
    }
    
    return render(request, 'monitoring/statistics.html', context)


@login_required
def completeness_view(request):
    """数据齐全性检查页面"""
    completeness_service = CompletenessService()
    
    project_id = request.GET.get('project_id')
    
    context = {
        'completeness': completeness_service.check_all_modules(project_id),
    }
    
    return render(request, 'monitoring/completeness.html', context)


@login_required
def ranking_view(request):
    """业务排名页面"""
    ranking_service = RankingService()
    
    # 获取筛选参数
    ranking_type = request.GET.get('type', 'project')  # project或person
    period = request.GET.get('period', 'annual')  # annual/quarterly/monthly
    
    context = {
        'ranking_type': ranking_type,
        'period': period,
        'rankings': ranking_service.get_rankings(ranking_type, period),
    }
    
    return render(request, 'monitoring/ranking.html', context)


# API接口
@login_required
def api_archive_stats(request):
    """归档统计API"""
    archive_service = ArchiveMonitorService()
    data = archive_service.get_archive_overview()
    return JsonResponse(data)


@login_required
def api_update_stats(request):
    """数据更新统计API"""
    update_service = UpdateMonitorService()
    data = update_service.get_project_update_status()
    return JsonResponse({'data': data})
```

### 7.2 报表生成视图

```python
# reports/views.py

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse, FileResponse, HttpResponse
from django.contrib import messages
from reports.generators.weekly_generator import WeeklyReportGenerator
from reports.generators.monthly_generator import MonthlyReportGenerator
from reports.generators.quarterly_generator import QuarterlyReportGenerator
from reports.generators.annual_generator import AnnualReportGenerator
from reports.exporters.excel_exporter import ExcelExporter
from reports.exporters.pdf_exporter import PDFExporter
from reports.models import ReportRecord
from datetime import date, datetime
import os


@login_required
def report_list(request):
    """报表列表页面"""
    reports = ReportRecord.objects.all().order_by('-created_at')[:50]
    
    context = {
        'reports': reports,
    }
    
    return render(request, 'reports/report_list.html', context)


@login_required
def generate_report(request):
    """生成报表"""
    if request.method == 'POST':
        report_type = request.POST.get('report_type')
        file_format = request.POST.get('file_format', 'excel')
        
        try:
            # 根据报表类型生成数据
            if report_type == 'weekly':
                generator = WeeklyReportGenerator()
            elif report_type == 'monthly':
                year = int(request.POST.get('year', date.today().year))
                month = int(request.POST.get('month', date.today().month))
                generator = MonthlyReportGenerator(year, month)
            elif report_type == 'quarterly':
                year = int(request.POST.get('year', date.today().year))
                quarter = int(request.POST.get('quarter', 1))
                generator = QuarterlyReportGenerator(year, quarter)
            elif report_type == 'annual':
                year = int(request.POST.get('year', date.today().year))
                generator = AnnualReportGenerator(year)
            else:
                return JsonResponse({'success': False, 'message': '无效的报表类型'})
            
            # 生成报表数据
            report_data = generator.generate_data()
            
            # 导出文件
            if file_format == 'excel':
                exporter = ExcelExporter(report_data)
                file_path = exporter.export()
            elif file_format == 'pdf':
                exporter = PDFExporter(report_data)
                file_path = exporter.export()
            else:
                return JsonResponse({'success': False, 'message': '无效的文件格式'})
            
            # 保存报表记录
            record = ReportRecord.objects.create(
                report_type=report_type,
                period_start=report_data['period_start'],
                period_end=report_data['period_end'],
                generated_by=request.user.username,
                file_path=file_path,
                file_format=file_format,
                status='completed'
            )
            
            messages.success(request, f'报表生成成功！')
            return JsonResponse({
                'success': True,
                'message': '报表生成成功',
                'record_id': record.id,
                'download_url': f'/reports/download/{record.id}/'
            })
            
        except Exception as e:
            messages.error(request, f'报表生成失败：{str(e)}')
            return JsonResponse({'success': False, 'message': str(e)})
    
    # GET请求显示生成表单
    context = {
        'current_year': date.today().year,
        'current_month': date.today().month,
        'current_quarter': (date.today().month - 1) // 3 + 1,
    }
    return render(request, 'reports/generate_form.html', context)


@login_required
def download_report(request, record_id):
    """下载报表"""
    try:
        record = ReportRecord.objects.get(id=record_id)
        
        if not os.path.exists(record.file_path):
            messages.error(request, '报表文件不存在')
            return redirect('reports:report_list')
        
        # 确定文件MIME类型
        if record.file_format == 'excel':
            content_type = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            extension = 'xlsx'
        elif record.file_format == 'pdf':
            content_type = 'application/pdf'
            extension = 'pdf'
        else:
            content_type = 'application/octet-stream'
            extension = 'file'
        
        # 生成下载文件名
        filename = f"{record.report_type}_report_{record.period_start}_{record.period_end}.{extension}"
        
        # 返回文件
        response = FileResponse(
            open(record.file_path, 'rb'),
            content_type=content_type
        )
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        
        return response
        
    except ReportRecord.DoesNotExist:
        messages.error(request, '报表记录不存在')
        return redirect('reports:report_list')
    except Exception as e:
        messages.error(request, f'下载失败：{str(e)}')
        return redirect('reports:report_list')


@login_required
def preview_report(request, record_id):
    """预览报表（HTML格式）"""
    try:
        record = ReportRecord.objects.get(id=record_id)
        
        # 重新生成报表数据用于预览
        if record.report_type == 'weekly':
            generator = WeeklyReportGenerator(record.period_start)
        elif record.report_type == 'monthly':
            generator = MonthlyReportGenerator(
                record.period_start.year,
                record.period_start.month
            )
        elif record.report_type == 'quarterly':
            quarter = (record.period_start.month - 1) // 3 + 1
            generator = QuarterlyReportGenerator(
                record.period_start.year,
                quarter
            )
        elif record.report_type == 'annual':
            generator = AnnualReportGenerator(record.period_start.year)
        else:
            messages.error(request, '无效的报表类型')
            return redirect('reports:report_list')
        
        report_data = generator.generate_data()
        
        context = {
            'record': record,
            'report_data': report_data,
        }
        
        return render(request, 'reports/report_preview.html', context)
        
    except ReportRecord.DoesNotExist:
        messages.error(request, '报表记录不存在')
        return redirect('reports:report_list')
```

---

## 8. URL路由配置

```python
# monitoring/urls.py

from django.urls import path
from monitoring import views

app_name = 'monitoring'

urlpatterns = [
    path('', views.dashboard, name='dashboard'),
    path('archive/', views.archive_monitor, name='archive_monitor'),
    path('update/', views.update_monitor, name='update_monitor'),
    path('statistics/', views.statistics_view, name='statistics'),
    path('completeness/', views.completeness_view, name='completeness'),
    path('ranking/', views.ranking_view, name='ranking'),
    
    # API接口
    path('api/archive/stats/', views.api_archive_stats, name='api_archive_stats'),
    path('api/update/stats/', views.api_update_stats, name='api_update_stats'),
]


# reports/urls.py

from django.urls import path
from reports import views

app_name = 'reports'

urlpatterns = [
    path('', views.report_list, name='report_list'),
    path('generate/', views.generate_report, name='generate_report'),
    path('download/<int:record_id>/', views.download_report, name='download_report'),
    path('preview/<int:record_id>/', views.preview_report, name='preview_report'),
]


# config/urls.py (主URL配置)

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('monitoring/', include('monitoring.urls')),
    path('reports/', include('reports.urls')),
    # ... 其他URL配置
]
```

---

## 9. 缓存策略

### 9.1 缓存配置

```python
# config/settings.py

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'cache_table',
        'TIMEOUT': 3600,  # 1小时
        'OPTIONS': {
            'MAX_ENTRIES': 1000
        }
    }
}

# 创建缓存表命令：python manage.py createcachetable
```

### 9.2 缓存工具

```python
# monitoring/utils/cache_utils.py

from django.core.cache import cache
from django.utils import timezone
from datetime import timedelta
import hashlib
import json


class CacheManager:
    """缓存管理器"""
    
    # 缓存过期时间（秒）
    CACHE_TIMEOUT = {
        'archive': 1800,      # 归档监控：30分钟
        'update': 600,        # 数据更新：10分钟
        'statistics': 3600,   # 统计数据：1小时
        'completeness': 1800, # 齐全性：30分钟
        'ranking': 3600,      # 排名：1小时
    }
    
    @classmethod
    def get_cache_key(cls, cache_type, **kwargs):
        """生成缓存键
        
        Args:
            cache_type: 缓存类型
            **kwargs: 额外参数，用于区分不同的缓存
        
        Returns:
            缓存键字符串
        """
        # 将参数排序后序列化
        params_str = json.dumps(kwargs, sort_keys=True)
        params_hash = hashlib.md5(params_str.encode()).hexdigest()[:8]
        
        return f"{cache_type}:{params_hash}"
    
    @classmethod
    def get(cls, cache_type, **kwargs):
        """获取缓存数据
        
        Args:
            cache_type: 缓存类型
            **kwargs: 缓存参数
        
        Returns:
            缓存的数据，如果不存在或已过期则返回None
        """
        cache_key = cls.get_cache_key(cache_type, **kwargs)
        return cache.get(cache_key)
    
    @classmethod
    def set(cls, cache_type, data, **kwargs):
        """设置缓存数据
        
        Args:
            cache_type: 缓存类型
            data: 要缓存的数据
            **kwargs: 缓存参数
        """
        cache_key = cls.get_cache_key(cache_type, **kwargs)
        timeout = cls.CACHE_TIMEOUT.get(cache_type, 3600)
        cache.set(cache_key, data, timeout)
    
    @classmethod
    def delete(cls, cache_type, **kwargs):
        """删除缓存
        
        Args:
            cache_type: 缓存类型
            **kwargs: 缓存参数
        """
        cache_key = cls.get_cache_key(cache_type, **kwargs)
        cache.delete(cache_key)
    
    @classmethod
    def clear_all(cls, cache_type=None):
        """清除所有缓存或指定类型的缓存
        
        Args:
            cache_type: 缓存类型，如果为None则清除所有
        """
        if cache_type:
            # 清除特定类型的缓存
            # 注意：这需要遍历所有缓存键，性能开销较大
            pass
        else:
            # 清除所有缓存
            cache.clear()


# 使用示例
def get_archive_overview_with_cache():
    """带缓存的归档总览数据获取"""
    # 尝试从缓存获取
    cache_data = CacheManager.get('archive')
    
    if cache_data is not None:
        return cache_data
    
    # 缓存不存在，重新计算
    from monitoring.services.archive_service import ArchiveMonitorService
    service = ArchiveMonitorService()
    data = service.get_archive_overview()
    
    # 存入缓存
    CacheManager.set('archive', data)
    
    return data
```

---

## 10. 性能优化建议

### 10.1 数据库查询优化

1. **使用select_related和prefetch_related**
   ```python
   # 优化前
   projects = Project.objects.all()
   for project in projects:
       print(project.procurements.count())  # N+1查询问题
   
   # 优化后
   projects = Project.objects.prefetch_related('procurements')
   for project in projects:
       print(project.procurements.count())  # 只执行2条SQL
   ```

2. **添加数据库索引**
   ```python
   class Meta:
       indexes = [
           models.Index(fields=['platform_publicity_date']),
           models.Index(fields=['project', 'created_at']),
           models.Index(fields=['-created_at']),
       ]
   ```

3. **使用聚合查询**
   ```python
   # 使用数据库聚合而不是Python循环
   from django.db.models import Sum, Count
   
   stats = Project.objects.aggregate(
       total_contracts=Count('contracts'),
       total_amount=Sum('contracts__contract_amount')
   )
   ```

### 10.2 前端性能优化

1. **懒加载图表**
   - 使用Intersection Observer API
   - 只在图表可见时才渲染

2. **分页加载**
   - 大数据表格使用分页或虚拟滚动
   - API返回数据分页

3. **防抖和节流**
   - 搜索框输入使用防抖
   - 滚动事件使用节流

### 10.3 缓存策略

1. **多级缓存**
   - 浏览器缓存（静态资源）
   - 应用缓存（Django Cache）
   - 数据库缓存表

2. **缓存更新策略**
   - 数据变更时主动清除相关缓存
   - 定时任务预热常用缓存

---

## 11. 测试策略

### 11.1 单元测试

```python
# monitoring/tests/test_services.py

from django.test import TestCase
from monitoring.services.archive_service import ArchiveMonitorService
from procurement.models import Procurement
from contract.models import Contract
from project.models import Project


class ArchiveServiceTest(TestCase):
    """归档服务测试"""
    
    def setUp(self):
        """测试数据准备"""
        self.project = Project.objects.create(
            project_code='TEST001',
            project_name='测试项目'
        )
        
        self.procurement = Procurement.objects.create(
            procurement_code='P001',
            project=self.project,
            # ... 其他必填字段
        )
    
    def test_get_procurement_archive_stats(self):
        """测试采购归档统计"""
        service = ArchiveMonitorService()
        stats = service._get_procurement_archive_stats()
        
        self.assertIn('total', stats)
        self.assertIn('archived', stats)
        self.assertIn('rate', stats)
        self.assertGreaterEqual(stats['rate'], 0)
        self.assertLessEqual(stats['rate'], 100)
    
    def test_calculate_overdue(self):
        """测试逾期计算"""
        # ... 测试逾期逻辑
        pass
```

### 11.2 集成测试

```python
# monitoring/tests/test_views.py

from django.test import TestCase, Client
from django.contrib.auth.models import User
from django.urls import reverse


class MonitoringViewsTest(TestCase):
    """监控视图集成测试"""
    
    def setUp(self):
        self.client = Client()
        self.user = User.objects.create_user(
            username='testuser',
            password='testpass123'
        )
        self.client.login(username='testuser', password='testpass123')
    
    def test_dashboard_view(self):
        """测试仪表盘页面"""
        response = self.client.get(reverse('monitoring:dashboard'))
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'monitoring/dashboard.html')
    
    def test_api_archive_stats(self):
        """测试归档统计API"""
        response = self.client.get(reverse('monitoring:api_archive_stats'))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')
```

---

## 12. 部署注意事项

### 12.1 环境变量配置

```python
# .env.example

# 缓存配置
CACHE_BACKEND=django.core.cache.backends.db.DatabaseCache
CACHE_LOCATION=cache_table
CACHE_TIMEOUT=3600

# 报表导出目录
REPORT_EXPORT_DIR=data/exports/reports

# 性能配置
DB_CONN_MAX_AGE=60
```

### 12.2 初始化命令

```bash
# 创建缓存表
python manage.py createcachetable

# 运行迁移
python manage.py migrate monitoring
python manage.py migrate reports

# 创建报表导出目录
mkdir -p data/exports/reports
```

### 12.3 定时任务（可选）

```python
# 使用Django-crontab或Celery定时清理过期报表
from django.core.management.base import BaseCommand
from reports.models import ReportRecord
from datetime import datetime, timedelta
import os


class Command(BaseCommand):
    help = '清理30天前的报表文件'
    
    def handle(self, *args, **options):
        deadline = datetime.now() - timedelta(days=30)
        old_reports = ReportRecord.objects.filter(
            created_at__lt=deadline
        )
        
        for report in old_reports:
            # 删除文件
            if os.path.exists(report.file_path):
                os.remove(report.file_path)
            
            # 删除记录
            report.delete()
        
        self.stdout.write(
            self.style.SUCCESS(
                f'成功清理{old_reports.count()}个过期报表'
            )
        )
```

---

## 13. 总结

本设计方案完整地规划了监控指标体系和报表系统的实现，主要特点：

### 13.1 设计亮点

1. **模块化设计**：
   - 独立的monitoring和reports应用
   - 服务层、视图层、模板层清晰分离
   - 组件可复用

2. **性能优化**：
   - 多级缓存策略
   - 数据库查询优化
   - 前端懒加载

3. **扩展性强**：
   - 支持多种报表周期
   - 支持多种导出格式
   - 便于添加新指标

4. **用户友好**：
   - 可视化图表展示
   - 交互式筛选
   - 一键导出报表

### 13.2 下一步工作

1. 详细的开发计划制定
2. 前端UI/UX设计
3. 分阶段实施开发
4. 测试和优化

---

**文档状态：** ✅ 完成  
**下一步：** 创建详细的开发计划文档