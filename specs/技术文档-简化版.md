
# 项目采购与成本管理系统 - 技术设计文档（简化版）

## 文档说明

本文档是基于《技术文档审查报告》的建议，针对初学者和小规模系统优化后的技术方案。采用**渐进式开发策略**，从最简单的方案开始，根据实际需要逐步升级。

---

## 1. 文档概述

### 1.1 文档目的
为初学者提供清晰、可执行的技术实施方案，确保能在**2周内实现MVP最小可行产品**。

### 1.2 适用范围
- 初学者（有Python/爬虫基础）
- 小规模系统（用户<20人，数据<10万条）
- 快速上线需求（2-4周开发周期）

### 1.3 设计原则
- **KISS（简单至上）**：选择最简单的技术方案
- **YAGNI（你不需要它）**：只实现当前需要的功能
- **渐进式开发**：从简单到复杂，逐步优化

---

## 2. 技术方案路线图

### 2.1 三阶段技术方案

```
阶段一：MVP（2周）         阶段二：标准版（+3周）      阶段三：企业版（可选）
┌─────────────────┐       ┌─────────────────┐       ┌─────────────────┐
│ Django Admin    │  →    │ Vue 3 前端      │  →    │ PostgreSQL     │
│ SQLite          │       │ 自定义界面       │       │ Nginx          │
│ 开发服务器       │       │ Waitress        │       │ 高可用部署      │
└─────────────────┘       └─────────────────┘       └─────────────────┘
  学习成本: ⭐⭐             学习成本: ⭐⭐⭐⭐           学习成本: ⭐⭐⭐⭐⭐
  开发时间: 2周             开发时间: 3周             开发时间: 2周
```

### 2.2 方案对比

| 对比项 | 阶段一（推荐） | 阶段二 | 阶段三 |
|-------|-------------|--------|--------|
| 数据库 | SQLite | SQLite | PostgreSQL |
| 前端 | Django Admin | Vue 3 + Element Plus | Vue 3 + TypeScript |
| 部署 | 开发服务器 | Waitress | Nginx + Waitress |
| 学习难度 | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 开发时间 | 2周 | 5周 | 7周 |
| 维护难度 | 低 | 中 | 高 |
| 适用数据量 | <10万 | <50万 | 无限制 |
| 适用用户数 | <20人 | <100人 | 无限制 |

---

## 3. 阶段一：MVP实施方案（推荐）

### 3.1 技术栈

```
后端：Python 3.10+ + Django 4.2+
数据库：SQLite（Django内置支持）
前端：Django Admin（无需编写前端代码）
部署：Django开发服务器
依赖库：pandas, openpyxl（处理Excel）
```

### 3.2 环境搭建（30分钟）

#### 步骤1：安装Python
```bash
# 下载Python 3.10+
# https://www.python.org/downloads/

# 验证安装
python --version
```

#### 步骤2：创建项目
```bash
# 创建项目目录
mkdir procurement_system
cd procurement_system

# 创建虚拟环境
python -m venv venv

# 激活虚拟环境
venv\Scripts\activate  # Windows
source venv/bin/activate  # Linux/Mac

# 安装Django和依赖
pip install django pandas openpyxl
```

#### 步骤3：初始化Django项目
```bash
# 创建Django项目
django-admin startproject config .

# 创建应用
python manage.py startapp procurement
python manage.py startapp contract
python manage.py startapp payment
python manage.py startapp settlement
python manage.py startapp supplier_eval
```

### 3.3 数据库设计

#### 配置SQLite（默认配置，无需修改）
```python
# config/settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# 配置中文
LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'
USE_TZ = True
```

#### 核心模型定义

```python
# procurement/models.py
from django.db import models
from django.core.exceptions import ValidationError

class Procurement(models.Model):
    """采购管理"""
    procurement_code = models.CharField('招采编号', max_length=50, primary_key=True)
    project_name = models.CharField('采购项目名称', max_length=200)
    procurement_unit = models.CharField('采购单位', max_length=200, blank=True)
    winning_unit = models.CharField('中标单位', max_length=200, blank=True)
    winning_contact = models.CharField('中标单位联系人', max_length=200, blank=True)
    procurement_method = models.CharField('采购方式', max_length=50, blank=True)
    
    CATEGORY_CHOICES = [
        ('工程', '工程'),
        ('货物', '货物'),
        ('服务', '服务'),
    ]
    procurement_category = models.CharField('采购类别', max_length=20, 
                                           choices=CATEGORY_CHOICES, blank=True)
    
    budget_amount = models.DecimalField('采购预算金额', max_digits=15, 
                                       decimal_places=2, null=True, blank=True)
    control_price = models.DecimalField('采购控制价', max_digits=15, 
                                       decimal_places=2, null=True, blank=True)
    winning_amount = models.DecimalField('中标金额', max_digits=15, 
                                        decimal_places=2, null=True, blank=True)
    
    planned_end_date = models.DateField('计划结束采购时间', null=True, blank=True)
    notice_issue_date = models.DateField('中标通知书发放日期', null=True, blank=True)
    procurement_officer = models.CharField('采购经办人', max_length=50, blank=True)
    demand_department = models.CharField('需求部门', max_length=100, blank=True)
    
    # 审计字段
    created_at = models.DateTimeField('创建时间', auto_now_add=True)
    updated_at = models.DateTimeField('更新时间', auto_now=True)
    created_by = models.CharField('创建人', max_length=50, blank=True)
    updated_by = models.CharField('更新人', max_length=50, blank=True)
    
    class Meta:
        verbose_name = '采购信息'
        verbose_name_plural = '采购信息'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.procurement_code} - {self.project_name}"


# contract/models.py
class Contract(models.Model):
    """合同管理"""
    contract_code = models.CharField('合同编号', max_length=50, primary_key=True)
    contract_name = models.CharField('合同名称', max_length=200)
    contract_officer = models.CharField('合同签订经办人', max_length=50, blank=True)
    
    CONTRACT_TYPE_CHOICES = [
        ('主合同', '主合同'),
        ('补充协议', '补充协议'),
        ('解除协议', '解除协议'),
    ]
    contract_type = models.CharField('合同类型', max_length=20, 
                                    choices=CONTRACT_TYPE_CHOICES, default='主合同')
    
    # 关联关系
    parent_contract = models.ForeignKey('self', on_delete=models.PROTECT, 
                                       verbose_name='关联主合同', 
                                       null=True, blank=True,
                                       related_name='supplements')
    procurement = models.ForeignKey('procurement.Procurement', 
                                   on_delete=models.PROTECT,
                                   verbose_name='关联采购', 
                                   null=True, blank=True,
                                   related_name='contracts')
    
    party_a = models.CharField('甲方', max_length=200, blank=True)
    party_b = models.CharField('乙方', max_length=200, blank=True)
    contract_amount = models.DecimalField('含税签约合同价', max_digits=15, 
                                         decimal_places=2, null=True, blank=True)
    signing_date = models.DateField('合同签订日期', null=True, blank=True)
    duration = models.CharField('合同工期/服务期限', max_length=100, blank=True)
    payment_method = models.TextField('支付方式', blank=True)
    
    # 审计字段
    created_at = models.DateTimeField('创建时间', auto_now_add=True)
    updated_at = models.DateTimeField('更新时间', auto_now=True)
    created_by = models.CharField('创建人', max_length=50, blank=True)
    updated_by = models.CharField('更新人', max_length=50, blank=True)
    
    class Meta:
        verbose_name = '合同信息'
        verbose_name_plural = '合同信息'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.contract_code} - {self.contract_name}"
    
    def clean(self):
        """数据验证"""
        # 验证：补充协议必须关联主合同
        if self.contract_type == '补充协议' and not self.parent_contract:
            raise ValidationError('补充协议必须关联主合同')
        
        # 验证：主合同不能关联其他合同
        if self.contract_type == '主合同' and self.parent_contract:
            raise ValidationError('主合同不能关联其他合同')
    
    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)


# payment/models.py
class Payment(models.Model):
    """付款管理"""
    payment_code = models.CharField('付款编号', max_length=50, primary_key=True)
    contract = models.ForeignKey('contract.Contract', on_delete=models.PROTECT,
                                verbose_name='关联合同', related_name='payments')
    payment_amount = models.DecimalField('实付金额', max_digits=15, decimal_places=2)
    payment_date = models.DateField('付款日期')
    
    # 审计字段
    created_at = models.DateTimeField('创建时间', auto_now_add=True)
    updated_at = models.DateTimeField('更新时间', auto_now=True)
    created_by = models.CharField('创建人', max_length=50, blank=True)
    updated_by = models.CharField('更新人', max_length=50, blank=True)
    
    class Meta:
        verbose_name = '付款信息'
        verbose_name_plural = '付款信息'
        ordering = ['-payment_date']
    
    def __str__(self):
        return f"{self.payment_code} - {self.payment_amount}元"
    
    def clean(self):
        """验证：累计付款不超过合同金额的120%"""
        if not self.contract.contract_amount:
            return
        
        from django.db.models import Sum
        total_paid = Payment.objects.filter(contract=self.contract).aggregate(
            total=Sum('payment_amount')
        )['total'] or 0
        
        if self.pk:  # 更新时排除自己
            old_amount = Payment.objects.get(pk=self.pk).payment_amount
            total_paid -= old_amount
        
        total_paid += self.payment_amount
        
        if total_paid > self.contract.contract_amount * 1.2:
            raise ValidationError(
                f'累计付款 {total_paid} 元超过合同金额 '
                f'{self.contract.contract_amount} 元的120%'
            )


# settlement/models.py
class Settlement(models.Model):
    """结算管理"""
    settlement_code = models.CharField('结算编号', max_length=50, primary_key=True)
    contract = models.OneToOneField('contract.Contract', on_delete=models.PROTECT,
                                   verbose_name='关联合同', related_name='settlement')
    final_amount = models.DecimalField('最终结算金额', max_digits=15, decimal_places=2)
    completion_date = models.DateField('完成日期', null=True, blank=True)
    
    # 审计字段
    created_at = models.DateTimeField('创建时间', auto_now_add=True)
    updated_at = models.DateTimeField('更新时间', auto_now=True)
    created_by = models.CharField('创建人', max_length=50, blank=True)
    updated_by = models.CharField('更新人', max_length=50, blank=True)
    
    class Meta:
        verbose_name = '结算信息'
        verbose_name_plural = '结算信息'
    
    def __str__(self):
        return f"{self.settlement_code} - {self.final_amount}元"


# supplier_eval/models.py
class SupplierEvaluation(models.Model):
    """供应商履约评价"""
    evaluation_code = models.CharField('评价编号', max_length=50, primary_key=True)
    contract = models.ForeignKey('contract.Contract', on_delete=models.PROTECT,
                                verbose_name='关联合同', related_name='evaluations')
    supplier_name = models.CharField('供应商名称', max_length=200)
    evaluation_period = models.CharField('评价日期区间', max_length=100, blank=True)
    evaluator = models.CharField('评价人员', max_length=50, blank=True)
    score = models.DecimalField('评分', max_digits=5, decimal_places=2, 
                               null=True, blank=True)
    
    EVAL_TYPE_CHOICES = [
        ('末次评价', '末次评价'),
        ('履约过程评价', '履约过程评价'),
    ]
    evaluation_type = models.CharField('评价类型', max_length=20, 
                                      choices=EVAL_TYPE_CHOICES, blank=True)
    
    # 审计字段
    created_at = models.DateTimeField('创建时间', auto_now_add=True)
    updated_at = models.DateTimeField('更新时间', auto_now=True)
    created_by = models.CharField('创建人', max_length=50, blank=True)
    updated_by = models.CharField('更新人', max_length=50, blank=True)
    
    class Meta:
        verbose_name = '供应商评价'
        verbose_name_plural = '供应商评价'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.evaluation_code} - {self.supplier_name}"
```

### 3.4 配置Django Admin

```python
# procurement/admin.py
from django.contrib import admin
from .models import Procurement

@admin.register(Procurement)
class ProcurementAdmin(admin.ModelAdmin):
    list_display = ['procurement_code', 'project_name', 'winning_unit', 
                   'winning_amount', 'procurement_officer', 'created_at']
    search_fields = ['procurement_code', 'project_name', 'winning_unit']
    list_filter = ['procurement_category', 'created_at']
    date_hierarchy = 'created_at'
    
    fieldsets = (
        ('基本信息', {
            'fields': ('procurement_code', 'project_name', 'procurement_unit')
        }),
        ('中标信息', {
            'fields': ('winning_unit', 'winning_contact', 'winning_amount')
        }),
        ('采购详情', {
            'fields': ('procurement_method', 'procurement_category', 
                      'budget_amount', 'control_price')
        }),
        ('时间信息', {
            'fields': ('planned_end_date', 'notice_issue_date')
        }),
        ('负责人信息', {
            'fields': ('procurement_officer', 'demand_department')
        }),
    )


# contract/admin.py
from django.contrib import admin
from .models import Contract

@admin.register(Contract)
class ContractAdmin(admin.ModelAdmin):
    list_display = ['contract_code', 'contract_name', 'contract_type',
                   'party_b', 'contract_amount', 'signing_date']
    search_fields = ['contract_code', 'contract_name', 'party_b']
    list_filter = ['contract_type', 'signing_date']
    autocomplete_fields = ['procurement', 'parent_contract']
    date_hierarchy = 'signing_date'
    
    fieldsets = (
        ('基本信息', {
            'fields': ('contract_code', 'contract_name', 'contract_type')
        }),
        ('关联信息', {
            'fields': ('parent_contract', 'procurement')
        }),
        ('合同方信息', {
            'fields': ('party_a', 'party_b')
        }),
        ('金额与时间', {
            'fields': ('contract_amount', 'signing_date', 'duration')
        }),
        ('其他信息', {
            'fields': ('contract_officer', 'payment_method'),
            'classes': ('collapse',)
        }),
    )


# payment/admin.py
from django.contrib import admin
from .models import Payment

@admin.register(Payment)
class PaymentAdmin(admin.ModelAdmin):
    list_display = ['payment_code', 'contract', 
'payment_amount', 'payment_date']
    search_fields = ['payment_code', 'contract__contract_code']
    list_filter = ['payment_date']
    autocomplete_fields = ['contract']
    date_hierarchy = 'payment_date'


# settlement/admin.py
from django.contrib import admin
from .models import Settlement

@admin.register(Settlement)
class SettlementAdmin(admin.ModelAdmin):
    list_display = ['settlement_code', 'contract', 'final_amount', 'completion_date']
    search_fields = ['settlement_code', 'contract__contract_code']
    autocomplete_fields = ['contract']


# supplier_eval/admin.py
from django.contrib import admin
from .models import SupplierEvaluation

@admin.register(SupplierEvaluation)
class SupplierEvaluationAdmin(admin.ModelAdmin):
    list_display = ['evaluation_code', 'supplier_name', 'score', 
                   'evaluation_type', 'created_at']
    search_fields = ['evaluation_code', 'supplier_name', 'contract__contract_code']
    list_filter = ['evaluation_type', 'created_at']
    autocomplete_fields = ['contract']
```

### 3.5 Excel导入功能

```python
# procurement/management/commands/import_excel.py
from django.core.management.base import BaseCommand
from procurement.models import Procurement
import pandas as pd

class Command(BaseCommand):
    help = '导入采购数据'
    
    def add_arguments(self, parser):
        parser.add_argument('file', type=str, help='Excel文件路径')
    
    def handle(self, *args, **options):
        try:
            df = pd.read_excel(options['file'])
            success_count = 0
            error_count = 0
            
            for idx, row in df.iterrows():
                try:
                    Procurement.objects.update_or_create(
                        procurement_code=row['招采编号'],
                        defaults={
                            'project_name': row.get('采购项目名称', ''),
                            'winning_unit': row.get('中标单位', ''),
                            'winning_amount': row.get('中标金额'),
                            'procurement_officer': row.get('采购经办人', ''),
                        }
                    )
                    success_count += 1
                except Exception as e:
                    error_count += 1
                    self.stdout.write(
                        self.style.ERROR(f'第{idx+2}行导入失败: {str(e)}')
                    )
            
            self.stdout.write(
                self.style.SUCCESS(
                    f'导入完成！成功: {success_count}, 失败: {error_count}'
                )
            )
        except Exception as e:
            self.stdout.write(self.style.ERROR(f'文件读取失败: {str(e)}'))


# 使用方法：
# python manage.py import_excel data.xlsx
```

#### 宽表转长表功能

```python
# payment/management/commands/convert_wide_to_long.py
from django.core.management.base import BaseCommand
from payment.models import Payment
from contract.models import Contract
import pandas as pd
import re
from datetime import datetime

class Command(BaseCommand):
    help = '将付款宽表转换为长表并导入'
    
    def add_arguments(self, parser):
        parser.add_argument('file', type=str, help='付款宽表Excel文件')
    
    def parse_month_to_date(self, month_str):
        """将"2022年1月"转换为"2022-01-01"""
        match = re.search(r'(\d{4})\D*(\d{1,2})', str(month_str))
        if not match:
            raise ValueError(f"无法解析日期: {month_str}")
        
        year = int(match.group(1))
        month = int(match.group(2))
        return datetime(year, month, 1).date()
    
    def handle(self, *args, **options):
        try:
            # 读取Excel
            df = pd.read_excel(options['file'])
            
            # 第一列是合同编号
            contract_col = df.columns[0]
            
            # 识别日期列
            date_cols = [col for col in df.columns[1:] 
                        if '年' in str(col) or '月' in str(col)]
            
            self.stdout.write(f"发现 {len(date_cols)} 个日期列")
            
            # 宽表转长表
            df_long = pd.melt(
                df,
                id_vars=[contract_col],
                value_vars=date_cols,
                var_name='月份',
                value_name='实付金额'
            )
            
            # 清理空值
            df_long = df_long[df_long['实付金额'].notna()]
            df_long = df_long[df_long['实付金额'] > 0]
            
            self.stdout.write(f"转换后有效记录: {len(df_long)} 条")
            
            # 导入数据
            success_count = 0
            error_count = 0
            
            # 按合同分组
            for contract_code, group in df_long.groupby(contract_col):
                try:
                    # 检查合同是否存在
                    contract = Contract.objects.get(contract_code=contract_code)
                    
                    # 为每条付款记录生成编号
                    for idx, row in enumerate(group.itertuples(), start=1):
                        payment_code = f"{contract_code}-FK-{idx:03d}"
                        payment_date = self.parse_month_to_date(row.月份)
                        payment_amount = float(row.实付金额)
                        
                        Payment.objects.update_or_create(
                            payment_code=payment_code,
                            defaults={
                                'contract': contract,
                                'payment_date': payment_date,
                                'payment_amount': payment_amount,
                            }
                        )
                        success_count += 1
                        
                except Contract.DoesNotExist:
                    error_count += len(group)
                    self.stdout.write(
                        self.style.ERROR(f'合同 {contract_code} 不存在')
                    )
                except Exception as e:
                    error_count += 1
                    self.stdout.write(
                        self.style.ERROR(f'导入失败: {str(e)}')
                    )
            
            self.stdout.write(
                self.style.SUCCESS(
                    f'导入完成！成功: {success_count}, 失败: {error_count}'
                )
            )
            
        except Exception as e:
            self.stdout.write(self.style.ERROR(f'处理失败: {str(e)}'))


# 使用方法：
# python manage.py convert_wide_to_long payment_wide.xlsx
```

### 3.6 注册应用和配置

```python
# config/settings.py
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    # 业务应用
    'procurement',
    'contract',
    'payment',
    'settlement',
    'supplier_eval',
]

# config/urls.py
from django.contrib import admin
from django.urls import path

urlpatterns = [
    path('admin/', admin.site.urls),
]

# 自定义Admin标题
admin.site.site_header = '项目采购与成本管理系统'
admin.site.site_title = '采购管理'
admin.site.index_title = '欢迎使用项目采购与成本管理系统'
```

### 3.7 执行迁移和启动

```bash
# 创建迁移文件
python manage.py makemigrations

# 执行迁移
python manage.py migrate

# 创建超级用户
python manage.py createsuperuser
# 输入用户名、邮箱、密码

# 启动开发服务器
python manage.py runserver 0.0.0.0:8000

# 访问系统
# http://服务器IP:8000/admin
```

### 3.8 Windows防火墙配置

```
控制面板 → Windows Defender防火墙 → 高级设置
→ 入站规则 → 新建规则
→ 端口 → TCP → 特定本地端口: 8000
→ 允许连接 → 所有配置文件
→ 名称: Django开发服务器
```

### 3.9 数据备份脚本

```python
# backup_db.py
import shutil
import datetime
import os

def backup_database():
    """备份SQLite数据库"""
    source = 'db.sqlite3'
    backup_dir = 'backups'
    
    # 创建备份目录
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)
    
    # 生成备份文件名
    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_file = os.path.join(backup_dir, f'db_backup_{timestamp}.sqlite3')
    
    # 复制数据库文件
    shutil.copy2(source, backup_file)
    
    print(f"✓ 数据库已备份到: {backup_file}")
    
    # 删除7天前的备份
    for file in os.listdir(backup_dir):
        file_path = os.path.join(backup_dir, file)
        if os.path.isfile(file_path):
            file_time = datetime.datetime.fromtimestamp(
                os.path.getctime(file_path)
            )
            if (datetime.datetime.now() - file_time).days > 7:
                os.remove(file_path)
                print(f"✓ 已删除旧备份: {file}")

if __name__ == '__main__':
    backup_database()
```

#### 配置Windows任务计划程序

```
1. 打开"任务计划程序"
2. 创建基本任务
3. 名称: 每日数据库备份
4. 触发器: 每天凌晨2:00
5. 操作: 启动程序
   程序: C:\path\to\venv\Scripts\python.exe
   参数: C:\path\to\backup_db.py
   起始于: C:\path\to\procurement_system
6. 完成
```

---

## 4. 阶段二：添加Vue前端（可选）

### 4.1 何时需要阶段二

```
✓ Django Admin界面已经满足基本需求
✓ 使用2-4周后发现：
  - 希望界面更美观
  - 需要更复杂的数据展示
  - 需要自定义工作流程

如果Admin够用，就不需要进入阶段二！
```

### 4.2 前端技术栈（简化版）

```
Vue 3.3+ (使用JavaScript，不用TypeScript)
Element Plus 2.3+
Axios 1.4+
Vue Router 4 (简化配置)
```

### 4.3 前端项目搭建

```bash
# 创建前端项目
npm create vue@latest

# 选择配置
✔ Project name: frontend
✔ Add TypeScript? No  # 不使用TypeScript
✔ Add JSX Support? No
✔ Add Vue Router? Yes
✔ Add Pinia? No  # 简单场景不需要
✔ Add Vitest? No
✔ Add Cypress? No
✔ Add ESLint? Yes
✔ Add Prettier? Yes

cd frontend
npm install
npm install element-plus axios
npm run dev
```

### 4.4 简单的前端示例

```vue
<!-- src/views/ProcurementList.vue -->
<template>
  <div class="procurement-list">
    <el-card>
      <template #header>
        <div class="card-header">
          <span>采购信息列表</span>
          <el-button type="primary" @click="handleAdd">新增采购</el-button>
        </div>
      </template>
      
      <!-- 搜索框 -->
      <el-input
        v-model="searchKeyword"
        placeholder="搜索项目名称或招采编号"
        @input="handleSearch"
        style="margin-bottom: 20px; width: 300px;"
      />
      
      <!-- 数据表格 -->
      <el-table :data="tableData" stripe style="width: 100%">
        <el-table-column prop="procurement_code" label="招采编号" width="150"/>
        <el-table-column prop="project_name" label="采购项目名称" width="300"/>
        <el-table-column prop="winning_unit" label="中标单位" width="200"/>
        <el-table-column prop="winning_amount" label="中标金额" width="150">
          <template #default="scope">
            {{ formatMoney(scope.row.winning_amount) }}
          </template>
        </el-table-column>
        <el-table-column label="操作" width="200">
          <template #default="scope">
            <el-button size="small" @click="handleEdit(scope.row)">编辑</el-button>
            <el-button size="small" type="danger" @click="handleDelete(scope.row)">
              删除
            </el-button>
          </template>
        </el-table-column>
      </el-table>
      
      <!-- 分页 -->
      <el-pagination
        v-model:current-page="currentPage"
        v-model:page-size="pageSize"
        :total="total"
        @current-change="fetchData"
        style="margin-top: 20px; text-align: right;"
      />
    </el-card>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import axios from 'axios'
import { ElMessage } from 'element-plus'

const tableData = ref([])
const searchKeyword = ref('')
const currentPage = ref(1)
const pageSize = ref(20)
const total = ref(0)

// 获取数据
const fetchData = async () => {
  try {
    const response = await axios.get('/api/procurement/', {
      params: {
        page: currentPage.value,
        page_size: pageSize.value,
        search: searchKeyword.value
      }
    })
    tableData.value = response.data.data.results
    total.value = response.data.data.total
  } catch (error) {
    ElMessage.error('获取数据失败')
  }
}

// 搜索
const handleSearch = () => {
  currentPage.value = 1
  fetchData()
}

// 格式化金额
const formatMoney = (amount) => {
  if (!amount) return '-'
  return `¥${amount.toLocaleString()}`
}

// 新增
const handleAdd = () => {
  // 跳转到新增页面或打开对话框
}

// 编辑
const handleEdit = (row) => {
  // 跳转到编辑页面或打开对话框
}

// 删除
const handleDelete = async (row) => {
  try {
    await axios.delete(`/api/procurement/${row.procurement_code}`)
    ElMessage.success('删除成功')
    fetchData()
  } catch (error) {
    ElMessage.error('删除失败')
  }
}

onMounted(() => {
  fetchData()
})
</script>

<style scoped>
.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
</style>
```

---

## 5. 常见问题解决

### 5.1 忘记管理员密码

```bash
python manage.py changepassword admin
```

### 5.2 数据库被锁定

```python
# settings.py添加超时配置
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
        'OPTIONS': {
            'timeout': 20,
        }
    }
}
```

### 5.3 局域网无法访问

```bash
# 1. 确认使用0.0.0.0而不是127.0.0.1
python manage.py runserver 0.0.0.0:8000

# 2. settings.py添加
ALLOWED_HOSTS = ['*']  # 开发环境可以用*

# 3. 检查防火墙是否开放8000端口
```

### 5.4 中文显示乱码

```python
# settings.py确认配置
LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'
USE_I18N = True
USE_TZ = True
```

### 5.5 Excel导入失败

```python
# 检查Excel文件格式
# 1. 确保是.xlsx格式（不是.xls）
# 2. 确保列名与模型字段对应
# 3. 
查看错误日志获取详细信息
```

---

## 6. 性能优化建议

### 6.1 数据库查询优化

```python
# 使用select_related减少数据库查询
contracts = Contract.objects.select_related('procurement', 'parent_contract').all()

# 使用prefetch_related优化反向关系
contracts = Contract.objects.prefetch_related('payments', 'evaluations').all()

# 添加数据库索引
class Contract(models.Model):
    signing_date = models.DateField(db_index=True)  # 添加索引
```

### 6.2 分页查询

```python
# 在Admin中配置分页
class ProcurementAdmin(admin.ModelAdmin):
    list_per_page = 20  # 每页显示20条
```

---

## 7. 项目结构总览

```
procurement_system/
├── config/                    # 项目配置
│   ├── settings.py           # Django设置
│   ├── urls.py              # 路由配置
│   └── wsgi.py              # WSGI配置
├── procurement/              # 采购管理应用
│   ├── models.py            # 数据模型
│   ├── admin.py             # Admin配置
│   └── management/          # 管理命令
│       └── commands/
│           └── import_excel.py
├── contract/                 # 合同管理应用
├── payment/                  # 付款管理应用
│   └── management/
│       └── commands/
│           └── convert_wide_to_long.py
├── settlement/               # 结算管理应用
├── supplier_eval/            # 供应商评价应用
├── db.sqlite3               # SQLite数据库文件
├── backup_db.py             # 备份脚本
├── backups/                 # 备份目录
├── manage.py                # Django管理脚本
└── requirements.txt         # Python依赖

requirements.txt内容：
Django==4.2.7
pandas==2.0.3
openpyxl==3.1.2
```

---

## 8. 2周开发计划

### 第1周：环境搭建与核心模型

**第1天：环境准备**
- [ ] 安装Python 3.10+
- [ ] 创建虚拟环境
- [ ] 安装Django和依赖
- [ ] 创建Django项目
- [ ] 学习Django基础（跟随官方教程第1-2部分）

**第2天：数据模型设计**
- [ ] 创建5个应用（procurement, contract, payment, settlement, supplier_eval）
- [ ] 定义Procurement模型
- [ ] 定义Contract模型
- [ ] 执行数据库迁移
- [ ] 测试模型创建和查询

**第3天：完善模型**
- [ ] 定义Payment模型
- [ ] 定义Settlement模型
- [ ] 定义SupplierEvaluation模型
- [ ] 添加数据验证逻辑
- [ ] 测试模型关联关系

**第4天：配置Admin后台**
- [ ] 配置Procurement Admin
- [ ] 配置Contract Admin
- [ ] 配置Payment Admin
- [ ] 配置Settlement Admin
- [ ] 配置SupplierEvaluation Admin
- [ ] 创建超级用户并测试

**第5天：Excel导入基础**
- [ ] 编写采购数据导入命令
- [ ] 编写合同数据导入命令
- [ ] 测试标准Excel导入功能
- [ ] 准备测试数据

### 第2周：Excel转换与部署

**第6天：宽表转长表功能**
- [ ] 编写付款宽表转长表命令
- [ ] 编写评价宽表转长表命令
- [ ] 测试转换功能
- [ ] 处理异常情况

**第7天：数据导入测试**
- [ ] 准备历史数据
- [ ] 批量导入采购数据
- [ ] 批量导入合同数据
- [ ] 转换并导入付款数据
- [ ] 验证数据完整性

**第8天：功能完善**
- [ ] 优化Admin界面
- [ ] 添加搜索和过滤
- [ ] 配置数据展示字段
- [ ] 测试所有功能

**第9天：备份与部署**
- [ ] 编写数据库备份脚本
- [ ] 配置Windows任务计划程序
- [ ] 配置Windows防火墙
- [ ] 启动开发服务器
- [ ] 局域网访问测试

**第10天：培训与文档**
- [ ] 编写用户操作手册
- [ ] 进行用户培训
- [ ] 收集反馈
- [ ] 修复问题
- [ ] 正式上线

---

## 9. 学习资源

### 9.1 Django学习

**官方文档（必读）：**
- Django官方教程：https://docs.djangoproject.com/zh-hans/4.2/intro/tutorial01/
- Django Admin文档：https://docs.djangoproject.com/zh-hans/4.2/ref/contrib/admin/

**视频教程：**
- B站搜索"Django入门教程"
- 推荐UP主的系列教程

**推荐书籍：**
- 《Django企业开发实战》
- 《精通Django》

### 9.2 Python数据处理

**Pandas学习：**
- Pandas官方教程：https://pandas.pydata.org/docs/getting_started/index.html
- 《利用Python进行数据分析》

### 9.3 前端学习（阶段二需要）

**Vue 3学习：**
- Vue 3官方文档：https://cn.vuejs.org/
- Element Plus文档：https://element-plus.org/zh-CN/

---

## 10. 总结

### 10.1 为什么选择这个方案？

```
✅ 学习成本低
   - Django Admin无需编写前端代码
   - SQLite零配置
   - 2周内可完成

✅ 维护简单
   - 备份=复制文件
   - 无需专业DBA
   - 问题容易排查

✅ 性能足够
   - 支持10万条数据
   - 响应时间<1秒
   - 满足20人使用

✅ 可扩展
   - 需要时可升级到PostgreSQL
   - 可添加Vue前端
   - 可增加高级功能
```

### 10.2 何时需要升级？

```
升级到PostgreSQL（阶段三）当：
❌ 数据量超过50万条
❌ 并发用户超过100人
❌ 需要复杂的数据分析
❌ 需要多服务器部署

在此之前，保持简单就好！
```

### 10.3 给初学者的最后建议

```
1. 不要害怕
   - Django比你想象的简单
   - Admin功能很强大
   - 遇到问题Google/GPT都能解决

2. 先让它运行起来
   - 不要追求完美
   - 能用就是好的
   - 后续可以优化

3. 渐进式开发
   - 从最简单的开始
   - 一个功能一个功能加
   - 根据反馈改进

4. 保持学习
   - 遇到不懂的就学
   - 做中学最快
   - 2周后你会发现其实不难

加油！你一定可以的！🚀
```

---

## 附录A：完整的requirements.txt

```txt
Django==4.2.7
pandas==2.0.3
openpyxl==3.1.2
python-dateutil==2.8.2
```

## 附录B：快速命令参考

```bash
# 环境管理
python -m venv venv                    # 创建虚拟环境
venv\Scripts\activate                  # 激活虚拟环境（Windows）
source venv/bin/activate               # 激活虚拟环境（Linux/Mac）
pip install -r requirements.txt        # 安装依赖

# Django项目管理
django-admin startproject config .     # 创建项目
python manage.py startapp appname      # 创建应用
python manage.py makemigrations        # 创建迁移文件
python manage.py migrate               # 执行迁移
python manage.py createsuperuser       # 创建管理员
python manage.py runserver 0.0.0.0:8000  # 启动服务器

# 数据管理
python manage.py import_excel data.xlsx              # 导入Excel
python manage.py convert_wide_to_long payment.xlsx   # 转换宽表
python backup_db.py                                  # 备份数据库

# 其他
python manage.py shell                 # 进入Django Shell
python manage.py dbshell               # 进入数据库Shell
python manage.py changepassword admin  # 修改管理员密码
```

## 附录C：常用Admin配置

```python
# 完整的Admin配置示例
@admin.register(ModelName)
class ModelNameAdmin(admin.ModelAdmin):
    # 列表页显示字段
    list_display = ['field1', 'field2', 'field3']
    
    # 搜索字段
    search_fields = ['field1', 'field2']
    
    # 过滤器
    list_filter = ['category', 'created_at']
    
    # 每页显示数量
    list_per_page = 20
    
    # 可编辑字段（列表页直接编辑）
    list_editable = ['status']
    
    # 排序
    ordering = ['-created_at']
    
    # 日期层级导航
    date_hierarchy = 'created_at'
    
    # 自动补全字段
    autocomplete_fields = ['foreign_key_field']
    
    # 只读字段
    readonly_fields = ['created_at', 'updated_at']
    
    # 字段分组
    fieldsets = (
        ('基本信息', {
            'fields': ('field1', 'field2')
        }),
        ('详细信息', {
            'fields': ('field3', 'field4'),
            'classes': ('collapse',)  # 可折叠
        }),
    )
```

---

**文档版本：** v1.0 简化版  
**最后更新：** 2025年10月20日  
**适用人群：** 初学者、小规模系统  
**预计开发时间：** 2周

**祝你成功！** 🎉
