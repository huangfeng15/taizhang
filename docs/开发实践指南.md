# 项目采购与成本管理系统 - 开发实践指南

## 文档信息

**文档版本：** v1.0  
**创建日期：** 2025-10-21  
**覆盖范围：** 开发规范、最佳实践、常见陷阱、设计模式应用  
**目标读者：** 开发人员、系统维护人员、技术团队  

---

## 1. 开发规范概述

### 1.1 规范目标

本指南旨在建立统一的开发标准，确保代码质量、可维护性和团队协作效率。遵循以下核心原则：

- ✅ **KISS（简单至上）**：保持代码简洁明了
- ✅ **YAGNI（你不需要它）**：只实现当前需要的功能
- ✅ **DRY（杜绝重复）**：避免代码重复，提高复用性
- ✅ **SOLID（坚实基础）**：遵循面向对象设计原则

### 1.2 技术栈规范

| 技术领域 | 选择标准 | 版本要求 | 说明 |
|----------|----------|----------|------|
| **后端框架** | Django | 5.2.7+ | 稳定成熟，快速开发 |
| **数据库** | SQLite | 3.x | 零配置，适合小规模 |
| **数据处理** | Pandas | 2.3.3+ | 强大的数据处理能力 |
| **Excel处理** | openpyxl | 3.1.5+ | 现代Excel文件支持 |
| **Python版本** | CPython | 3.10+ | 稳定性和性能平衡 |

### 1.3 项目结构规范

```
procurement_system/
├── config/                    # Django配置
│   ├── __init__.py
│   ├── settings.py           # 核心配置
│   ├── urls.py              # 路由配置
│   ├── wsgi.py              # WSGI配置
│   └── asgi.py              # ASGI配置
├── project/                   # 项目核心应用
│   ├── __init__.py
│   ├── models.py            # 项目模型
│   ├── views.py             # 视图函数
│   ├── admin.py             # Admin配置
│   ├── apps.py              # 应用配置
│   ├── tests.py             # 测试用例
│   └── templates/           # 模板文件
├── procurement/              # 采购管理应用
│   ├── __init__.py
│   ├── models.py            # 采购模型
│   ├── admin.py             # Admin配置
│   ├── apps.py              # 应用配置
│   ├── migrations/          # 数据库迁移
│   └── management/          # 管理命令
│       └── commands/
│           ├── import_excel.py
│           └── clear_all_data.py
├── contract/                 # 合同管理应用
├── payment/                  # 付款管理应用
├── settlement/               # 结算管理应用
├── supplier_eval/            # 供应商评价应用
├── data/                     # 数据文件
│   ├── imports/             # 导入文件
│   └── exports/             # 导出文件
├── docs/                     # 文档目录
├── scripts/                  # 运维脚本
├── backups/                  # 备份文件
├── logs/                     # 日志文件
├── requirements.txt          # Python依赖
├── manage.py                 # Django管理脚本
└── README.md                 # 项目说明
```

---

## 2. 代码规范

### 2.1 Python代码规范

#### 2.1.1 命名规范

```python
# 类名：使用PascalCase
class ProcurementManager:
    pass

# 函数名和变量名：使用snake_case
def calculate_payment_ratio(contract):
    total_paid = contract.get_total_paid_amount()
    return total_paid

# 常量：使用UPPER_CASE
DEFAULT_PAGE_SIZE = 20
MAX_UPLOAD_SIZE = 10 * 1024 * 1024  # 10MB

# 私有方法：使用前缀下划线
def _validate_business_rules(self):
    pass

# 模型字段：使用描述性名称
class Contract(models.Model):
    contract_code = models.CharField('合同编号', max_length=50)
    signing_date = models.DateField('签订日期')
    contract_amount = models.DecimalField('合同金额', max_digits=15, decimal_places=2)
```

#### 2.1.2 文档字符串规范

```python
def get_payment_ratio(self):
    """
    计算合同的付款比例
    
    计算公式：
        付款比例 = (累计付款金额 ÷ 基准金额) × 100%
    
    基准金额确定规则：
        1. 如果有结算价，使用结算价作为基准
        2. 否则使用（合同价 + 补充协议金额）作为基准
    
    Returns:
        float: 付款比例，范围0-100
        
    Raises:
        ValueError: 当基准金额为0时
        
    Example:
        >>> contract = Contract.objects.get(contract_code='HT2025001')
        >>> ratio = contract.get_payment_ratio()
        >>> print(f"付款比例: {ratio:.2f}%")
    """
    # 实现代码...
```

#### 2.1.3 导入规范

```python
# 标准库导入
import os
import logging
from datetime import date, timedelta
from decimal import Decimal

# Django导入
from django.db import models
from django.core.exceptions import ValidationError
from django.contrib import admin

# 第三方库导入
import pandas as pd
import openpyxl

# 本地应用导入
from project.models import Project
from procurement.models import BaseModel

# 导入顺序：标准库 → Django → 第三方库 → 本地应用
```

### 2.2 Django模型规范

#### 2.2.1 模型定义规范

```python
class Contract(BaseModel):
    """
    合同管理模型
    
    管理采购合同及其补充协议，支持主合同、补充协议、解除协议三种类型
    """
    
    # 主键字段
    contract_code = models.CharField(
        '合同编号',
        max_length=50,
        primary_key=True,
        help_text='合同唯一标识符，格式：HT2025001'
    )
    
    # 必填字段
    contract_name = models.CharField(
        '合同名称',
        max_length=200,
        blank=False,
        help_text='合同的正式名称'
    )
    
    # 可选字段
    contract_amount = models.DecimalField(
        '合同金额',
        max_digits=15,
        decimal_places=2,
        null=True,
        blank=True,
        help_text='含税签约合同价'
    )
    
    # 关联字段
    project = models.ForeignKey(
        'project.Project',
        on_delete=models.PROTECT,
        verbose_name='关联项目',
        null=True,
        blank=True,
        related_name='contracts',
        help_text='该合同所属的项目'
    )
    
    class Meta:
        verbose_name = '合同信息'
        verbose_name_plural = '合同信息'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['contract_code']),
            models.Index(fields=['signing_date']),
            models.Index(fields=['file_positioning']),
        ]
    
    def __str__(self):
        return f"{self.contract_code} - {self.contract_name}"
    
    def clean(self):
        """数据验证"""
        super().clean()
        self._validate_business_rules()
    
    def save(self, *args, **kwargs):
        """保存时执行完整验证"""
        self.full_clean()
        super().save(*args, **kwargs)
```

#### 2.2.2 查询优化规范

```python
# 好的做法：使用select_related优化正向关联
contracts = Contract.objects.select_related(
    'project', 'procurement', 'parent_contract'
).all()

# 好的做法：使用prefetch_related优化反向关联
contracts = Contract.objects.prefetch_related(
    'payments', 'evaluations', 'supplements'
).all()

# 好的做法：使用only()限制查询字段
contracts = Contract.objects.only(
    'contract_code', 'contract_name', 'contract_amount'
).all()

# 好的做法：批量操作
Contract.objects.filter(project=project).update(
    updated_by='admin',
    updated_at=timezone.now()
)

# 避免：N+1查询问题
# 错误示例：
contracts = Contract.objects.all()
for contract in contracts:
    project_name = contract.project.project_name  # 每次都查询数据库
```

### 2.3 视图函数规范

#### 2.3.1 视图函数结构

```python
from django.shortcuts import render, get_object_or_404
from django.db.models import Sum, Q
from django.core.paginator import Paginator
from django.contrib.auth.decorators import login_required

@login_required
def contract_list(request):
    """
    合同列表页面
    
    支持搜索、过滤、分页功能
    """
    # 获取查询参数
    search_query = request.GET.get('q', '')
    file_positioning_filter = request.GET.get('file_positioning', '')
    page = request.GET.get('page', 1)
    
    # 构建基础查询
    contracts = Contract.objects.select_related('project')
    
    # 应用过滤条件
    if search_query:
        contracts = contracts.filter(
            Q(contract_code__icontains=search_query) |
            Q(contract_name__icontains=search_query) |
            Q(party_b__icontains=search_query)
        )
    
    if file_positioning_filter:
        contracts = contracts.filter(file_positioning=file_positioning_filter)
    
    # 排序
    contracts = contracts.order_by('-signing_date')
    
    # 分页处理
    paginator = Paginator(contracts, 20)
    page_obj = paginator.get_page(page)
    
    # 渲染模板
    context = {
        'contracts': page_obj,
        'page_obj': page_obj,
        'search_query': search_query,
        'file_positioning_filter': file_positioning_filter,
    }
    
    return render(request, 'contract_list.html', context)
```

#### 2.3.2 API视图规范

```python
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.views import View

@method_decorator(csrf_exempt, name='dispatch')
class ContractAPIView(View):
    """合同API视图"""
    
    def get(self, request, contract_code=None):
        """获取合同信息"""
        if contract_code:
            # 获取单个合同
            contract = get_object_or_404(Contract, contract_code=contract_code)
            data = {
                'contract_code': contract.contract_code,
                'contract_name': contract.contract_name,
                'contract_amount': float(contract.contract_amount) if contract.contract_amount else None,
            }
            return JsonResponse({'data': data})
        else:
            # 获取合同列表
            contracts = Contract.objects.all()
            data = [
                {
                    'contract_code': c.contract_code,
                    'contract_name': c.contract_name,
                }
                for c in contracts
            ]
            return JsonResponse({'data': data})
    
    @require_POST
    def post(self, request):
        """创建合同"""
        try:
            data = json.loads(request.body)
            contract = Contract.objects.create(**data)
            return JsonResponse({
                'success': True,
                'contract_code': contract.contract_code
            })
        except Exception as e:
            return JsonResponse({
                'success': False,
                'message': str(e)
            }, status=400)
```

---

## 3. 设计模式应用

### 3.1 抽象基类模式（Template Method）

#### 3.1.1 模式应用

```python
class BaseModel(models.Model):
    """
    抽象基类 - 模板方法模式
    
    为所有业务模型提供通用的审计字段和行为
    """
    created_at = models.DateTimeField('创建时间', auto_now_add=True)
    updated_at = models.DateTimeField('更新时间', auto_now=True)
    created_by = models.CharField('创建人', max_length=50, blank=True)
    updated_by = models.CharField('更新人', max_length=50, blank=True)
    
    class Meta:
        abstract = True
        ordering = ['-created_at']
    
    def save(self, *args, **kwargs):
        """模板方法：定义保存流程"""
        # 步骤1：前置处理
        self._pre_save()
        
        # 步骤2：执行验证
        self.full_clean()
        
        # 步骤3：调用父类保存
        super().save(*args, **kwargs)
        
        # 步骤4：后置处理
        self._post_save()
    
    def _pre_save(self):
        """前置处理 - 子类可重写"""
        pass
    
    def _post_save(self):
        """后置处理 - 子类可重写"""
        pass
    
    def get_audit_info(self):
        """获取审计信息 - 具体实现"""
        return {
            'created_at': self.created_at,
            'updated_at': self.updated_at,
            'created_by': self.created_by,
            'updated_by': self.updated_by,
        }

# 具体实现类
class Contract(BaseModel):
    contract_code = models.CharField('合同编号', max_length=50, primary_key=True)
    contract_name = models.CharField('合同名称', max_length=200)
    
    def _pre_save(self):
        """重写前置处理"""
        if not self.created_by:
            self.created_by = get_current_user()
        
        self.updated_by = get_current_user()
```

#### 3.1.2 优势分析

- ✅ **代码复用**：所有模型自动获得审计字段
- ✅ **一致性**：统一的保存流程和验证逻辑
- ✅ **扩展性**：子类可以重写特定步骤
- ✅ **维护性**：修改审计逻辑只需在基类中进行

### 3.2 策略模式（Strategy）

#### 3.2.1 模式应用

```python
class DataImportStrategy:
    """数据导入策略接口"""
    
    def import_data(self, file_path, **kwargs):
        """导入数据的抽象方法"""
        raise NotImplementedError
    
    def validate_data(self, data):
        """验证数据的抽象方法"""
        raise NotImplementedError

class LongTableImportStrategy(DataImportStrategy):
    """长表导入策略"""
    
    def import_data(self, file_path, **kwargs):
        """长表数据导入实现"""
        import pandas as pd
        
        # 读取CSV文件
        df = pd.read_csv(file_path, encoding=kwargs.get('encoding', 'utf-8'))
        
        # 数据验证
        validated_data = self.validate_data(df)
        
        # 批量导入
        return self._bulk_create(validated_data)
    
    def validate_data(self, data):
        """长表数据验证"""
        required_columns = ['合同编号', '合同名称']
        
        for col in required_columns:
            if col not in data.columns:
                raise ValueError(f"缺少必需列: {col}")
        
        return data.dropna(subset=required_columns)

class WideTableImportStrategy(DataImportStrategy):
    """宽表导入策略"""
    
    def import_data(self, file_path, **kwargs):
        """宽表数据导入实现"""
        import pandas as pd
        
        # 读取Excel文件
        df = pd.read_excel(file_path)
        
        # 识别日期列
        date_columns = self._identify_date_columns(df)
        
        # 宽表转长表
        long_data = self._convert_wide_to_long(df, date_columns)
        
        # 数据验证
        validated_data = self.validate_data(long_data)
        
        # 批量导入
        return self._bulk_create(validated_data)
    
    def validate_data(self, data):
        """宽表数据验证"""
        # 验证转换后的数据格式
        if 'period' not in data.columns or 'value' not in data.columns:
            raise ValueError("宽表转换失败")
        
        return data[data['value'].notna()]
    
    def _identify_date_columns(self, df):
        """识别日期列"""
        import re
        date_pattern = re.compile(r'\d{4}\D*\d{1,2}月?')
        return [col for col in df.columns if date_pattern.search(str(col))]
    
    def _convert_wide_to_long(self, df, date_columns):
        """宽表转长表"""
        id_columns = [col for col in df.columns if col not in date_columns]
        return pd.melt(df, id_vars=id_columns, value_vars=date_columns, 
                      var_name='period', value_name='value')

class DataImporter:
    """数据导入器 - 使用策略模式"""
    
    def __init__(self):
        self.strategies = {
            'long': LongTableImportStrategy(),
            'wide': WideTableImportStrategy(),
        }
    
    def import_data(self, file_path, mode='long', **kwargs):
        """根据模式选择策略导入数据"""
        strategy = self.strategies.get(mode)
        if not strategy:
            raise ValueError(f"不支持的导入模式: {mode}")
        
        return strategy.import_data(file_path, **kwargs)

# 使用示例
importer = DataImporter()
result = importer.import_data('data.xlsx', mode='wide', encoding='utf-8')
```

#### 3.2.2 优势分析

- ✅ **开闭原则**：对扩展开放，可轻松添加新的导入策略
- ✅ **单一职责**：每种策略专注于特定的导入逻辑
- ✅ **可配置性**：运行时选择不同的策略
- ✅ **可测试性**：每个策略可以独立测试

### 3.3 工厂方法模式（Factory Method）

#### 3.3.1 模式应用

```python
class CodeGenerator:
    """编号生成器工厂"""
    
    @staticmethod
    def generate_payment_code(contract, payment_date=None):
        """生成付款编号的工厂方法"""
        if not payment_date:
            payment_date = timezone.now().date()
        
        # 确定合同标识
        contract_identifier = contract.contract_sequence or contract.contract_code
        
        # 查询现有付款记录
        existing_payments = Payment.objects.filter(
            contract=contract
        ).order_by('payment_date', 'created_at')
        
        # 计算序号
        sequence = CodeGenerator._calculate_sequence(
            existing_payments, payment_date
        )
        
        return f"{contract_identifier}-FK-{sequence:03d}"
    
    @staticmethod
    def generate_evaluation_code(contract, sequence):
        """生成评价编号的工厂方法"""
        return f"{contract.contract_code}-PJ-{sequence:03d}"
    
    @staticmethod
    def _calculate_sequence(payments, new_payment_date):
        """计算序号的辅助方法"""
        sequence = 1
        for payment in payments:
            if payment.payment_date < new_payment_date:
                sequence += 1
            elif (payment.payment_date == new_payment_date and 
                  payment.created_at < timezone.now()):
                sequence += 1
        return sequence

# 在模型中使用工厂方法
class Payment(BaseModel):
    payment_code = models.CharField('付款编号', max_length=50, primary_key=True, blank=True)
    
    def save(self, *args, **kwargs):
        if not self.payment_code:
            self.payment_code = CodeGenerator.generate_payment_code(
                self.contract, self.payment_date
            )
        super().save(*args, **kwargs)
```

#### 3.3.2 优势分析

- ✅ **封装复杂性**：隐藏编号生成的复杂逻辑
- ✅ **一致性**：确保所有编号格式统一
- ✅ **可维护性**：修改编号规则只需修改工厂方法
- ✅ **可扩展性**：可以轻松添加新的编号生成规则

### 3.4 观察者模式（Observer）

#### 3.4.1 模式应用

```python
from django.db.models.signals import post_save, pre_save
from django.dispatch import receiver
import logging

logger = logging.getLogger(__name__)

class AuditObserver:
    """审计观察者"""
    
    @staticmethod
    @receiver(pre_save, sender=Contract)
    def contract_pre_save(sender, instance, **kwargs):
        """合同保存前的审计处理"""
        # 记录变更信息
        if instance.pk:
            try:
                old_instance = sender.objects.get(pk=instance.pk)
                changes = AuditObserver._get_changes(old_instance, instance)
                if changes:
                    logger.info(f"合同 {instance.contract_code} 变更: {changes}")
            except sender.DoesNotExist:
                pass
    
    @staticmethod
    @receiver(post_save, sender=Contract)
    def contract_post_save(sender, instance, created, **kwargs):
        """合同保存后的审计处理"""
        if created:
            logger.info(f"新合同创建: {instance.contract_code}")
            # 发送通知
            NotificationService.send_contract_created_notification(instance)
        else:
            logger.info(f"合同更新: {instance.contract_code}")
    
    @staticmethod
    def _get_changes(old_instance, new_instance):
        """获取变更内容"""
        changes = {}
        for field in old_instance._meta.fields:
            old_value = getattr(old_instance, field.name)
            new_value = getattr(new_instance, field.name)
            if old_value != new_value:
                changes[field.name] = {
                    'old': old_value,
                    'new': new_value
                }
        return changes

class NotificationService:
    """通知服务"""
    
    @staticmethod
    def send_contract_created_notification(contract):
        """发送合同创建通知"""
        # 实现通知逻辑
        pass

class DataSyncObserver:
    """数据同步观察者"""
    
    @staticmethod
    @receiver(post_save, sender=Payment)
    def payment_post_save(sender, instance, created, **kwargs):
        """付款保存后同步相关数据"""
        if created:
            # 清除相关缓存
            cache_key = f'payment_ratio_{instance.contract.contract_code}'
            cache.delete(cache_key)
            
            # 更新合同统计信息
            instance.contract.update_statistics()
```

#### 3.4.2 优势分析

- ✅ **松耦合**：观察者和被观察者之间松耦合
- ✅ **可扩展性**：可以轻松添加新的观察者
- ✅ **实时响应**：事件发生时自动触发相关处理
- ✅ **关注点分离**：业务逻辑和辅助逻辑分离

---

## 4. 数据处理最佳实践

### 4.1 Excel数据处理

#### 4.1.1 文件读取最佳实践

```python
import pandas as pd
import chardet
from openpyxl import load_workbook

class ExcelProcessor:
    """Excel处理器"""
    
    @staticmethod
    def detect_encoding(file_path):
        """自动检测文件编码"""
        with open(file_path, 'rb') as f:
            raw_data = f.read(10000)
            result = chardet.detect(raw_data)
            
            if result['confidence'] > 0.7:
                encoding_map = {
                    'GB2312': 'gbk',
                    'ISO-8859-1': 'latin1',
                    'ascii': 'utf-8',
                }
                return encoding_map.get(result['encoding'], result['encoding'])
            
            return 'utf-8-sig'
    
    @staticmethod
    def read_excel_safe(file_path, encoding=None):
        """安全读取Excel文件"""
        try:
            # 自动检测编码
            if not encoding and file_path.endswith('.csv'):
                encoding = ExcelProcessor.detect_encoding(file_path)
            
            # 根据文件扩展名选择读取方法
            if file_path.endswith('.xlsx'):
                df = pd.read_excel(file_path)
            elif file_path.endswith('.csv'):
                df = pd.read_csv(file_path, encoding=encoding)
            else:
                raise ValueError(f"不支持的文件格式: {file_path}")
            
            return df
            
        except Exception as e:
            logger.error(f"读取文件失败: {file_path}, 错误: {str(e)}")
            raise
    
    @staticmethod
    def validate_columns(df, required_columns):
        """验证必需列"""
        missing_columns = [col for col in required_columns if col not in df.columns]
        if missing_columns:
            raise ValueError(f"缺少必需列: {missing_columns}")
        
        return True
    
    @staticmethod
    def clean_data(df):
        """清理数据"""
        # 删除完全空的行
        df = df.dropna(how='all')
        
        # 删除完全空的列
        df = df.dropna(axis=1, how='all')
        
        # 重置索引
        df = df.reset_index(drop=True)
        
        return df
```

#### 4.1.2 宽表转长表处理

```python
class WideTableConverter:
    """宽表转换器"""
    
    @staticmethod
    def convert_payment_wide_to_long(df):
        """付款宽表转长表"""
        # 识别日期列
        date_columns = WideTableConverter._identify_date_columns(df)
        
        if not date_columns:
            raise ValueError("未能识别日期列")
        
        # 确定ID列
        id_columns = [col for col in df.columns if col not in date_columns]
        
        # 执行逆透视
        df_long = pd.melt(
            df,
            id_vars=id_columns,
            value_vars=date_columns,
            var_name='period',
            value_name='amount'
        )
        
        # 清理数据
        df_long = WideTableConverter._clean_long_data(df_long)
        
        return df_long
    
    @staticmethod
    def _identify_date_columns(columns):
        """识别日期列"""
        import re
        patterns = [
            re.compile(r'\d{4}\D*\d{1,2}月?'),  # 2022年1月
            re.compile(r'\d{4}\D*(上|下)半年'),  # 2022年上半年
        ]
        
        date_columns = []
        for col in columns:
            col_str = str(col)
            if any(pattern.search(col_str) for pattern in patterns):
                date_columns.append(col)
        
        return date_columns
    
    @staticmethod
    def _clean_long_data(df):
        """清理长表数据"""
        # 删除空值
        df = df[df['amount'].notna()]
        
        # 删除零值
        df = df[df['amount'] > 0]
        
        # 转换数据类型
        df['amount'] = pd.to_numeric(df['amount'], errors='coerce')
        
        return df.dropna()
```

### 4.2 数据验证最佳实践

#### 4.2.1 分层验证策略

```python
class DataValidator:
    """数据验证器"""
    
    @staticmethod
    def validate_row_data(row, validation_rules):
        """验证单行数据"""
        errors = {}
        
        for field, rules in validation_rules.items():
            value = row.get(field)
            field_errors = DataValidator._validate_field(value, rules)
            if field_errors:
                errors[field] = field_errors
        
        return errors
    
    @staticmethod
    def _validate_field(value, rules):
        """验证单个字段"""
        errors = []
        
        # 必填验证
        if rules.get('required', False) and (value is None or str(value).strip() == ''):
            errors.append('此字段为必填项')
            return errors
        
        # 如果值为空且非必填，跳过其他验证
        if value is None or str(value).strip() == '':
            return errors
        
        # 类型验证
        field_type = rules.get('type')
        if field_type == 'decimal':
            try:
                Decimal(str(value))
            except (ValueError, InvalidOperation):
                errors.append('必须是有效的数字')
        
        elif field_type == 'date':
            try:
                parse_date(str(value))
            except ValueError:
                errors.append('必须是有效的日期')
        
        elif field_type == 'choice':
            choices = rules.get('choices', [])
            if value not in choices:
                errors.append(f'必须是以下选项之一: {choices}')
        
        # 范围验证
        min_value = rules.get('min_value')
        max_value = rules.get('max_value')
        
        if min_value is not None and value < min_value:
            errors.append(f'不能小于 {min_value}')
        
        if max_value is not None and value > max_value:
            errors.append(f'不能大于 {max_value}')
        
        return errors

# 验证规则定义
CONTRACT_VALIDATION_RULES = {
    'contract_code': {
        'required': True,
        'type': 'string',
        'max_length': 50,
    },
    'contract_amount': {
        'required': False,
        'type': 'decimal',
        'min_value': 0,
        'max_value': Decimal('999999999999.99'),
    },
    'signing_date': {
        'required': False,
        'type': 'date',
    },
    'file_positioning': {
        'required': True,
        'type': 'choice',
        'choices': ['主合同', '补充协议', '解除协议'],
    }
}
```

#### 4.2.2 批量验证优化

```python
class BatchValidator:
    """批量验证器"""
    
    @staticmethod
    def validate_dataframe(df, validation_rules):
        """批量验证DataFrame"""
        errors = {}
        
        # 使用向量化操作提高性能
        for field, rules in validation_rules.items():
            if field not in df.columns:
                continue
            
            series = df[field]
            field_errors = BatchValidator._validate_series(series, rules)
            
            if field_errors:
                errors[field] = field_errors
        
        return errors
    
    @staticmethod
    def _validate_series(series, rules):
        """验证Series"""
        errors = {}
        
        # 必填验证
        if rules.get('required', False):
            null_mask = series.isnull() | (series.astype(str).str.strip() == '')
            null_indices = series[null_mask].index.tolist()
            if null_indices:
                errors['required'] = null_indices
        
        # 类型验证
        field_type = rules.get('type')
        if field_type == 'decimal':
            try:
                pd.to_numeric(series, errors='coerce')
            except:
                pass  # 错误会在下面的检查中处理
        
        # 范围验证
        min_value = rules.get('min_value')
        max_value = rules.get('max_value')
        
        if min_value is not None or max_value is not None:
            numeric_series = pd.to_numeric(series, errors='coerce')
            
            if min_value is not None:
                below_min = numeric_series < min_value
                below_indices = numeric_series[below_min].index.tolist()
                if below_indices:
                    errors['min_value'] = below_indices
            
            if max_value is not None:
                above_max = numeric_series > max_value
                above_indices = numeric_series[above_max].index.tolist()
                if above_indices:
                    errors['max_value'] = above_indices
        
        return errors
```

---

## 5. 性能优化实践

### 5.1 数据库查询优化

#### 5.1.1 查询优化技巧

```python
class OptimizedQueries:
    """优化查询示例"""
    
    @staticmethod
    def get_contract_statistics_optimized():
        """优化的合同统计查询"""
        # 使用聚合查询减少数据传输
        stats = Contract.objects.aggregate(
            total_contracts=Count('contract_code'),
            total_amount=Sum('contract_amount'),
            avg_amount=Avg('contract_amount'),
            max_amount=Max('contract_amount'),
            min_amount=Min('contract_amount'),
        )
        
        return stats
    
    @staticmethod
    def get_project_contracts_optimized(project_code):
        """优化的项目合同查询"""
        # 使用select_related减少查询次数
        contracts = Contract.objects.select_related(
            'project', 'procurement', 'parent_contract'
        ).filter(
            project__project_code=project_code
        ).annotate(
            payment_count=Count('payments'),
            total_paid=Sum('payments__payment_amount'),
        ).order_by('-signing_date')
        
        return contracts
    
    @staticmethod
    def get_payment_progress_optimized():
        """优化的付款进度查询"""
        # 使用子查询和聚合
        from django.db.models import Subquery, OuterRef
        
        # 子查询：每个合同的最新付款日期
        latest_payment = Payment.objects.filter(
            contract=OuterRef('pk')
        ).order_by('-payment_date').values('payment_date')[:1]
        
        contracts = Contract.objects.annotate(
            latest_payment_date=Subquery(latest_payment),
            payment_count=Count('payments'),
            total_paid=Sum('payments__payment_amount'),
        ).filter(
            latest_payment_date__isnull=False
        ).order_by('-latest_payment_date')
        
        return contracts
```

#### 5.1.2 索引优化策略

```python
class IndexOptimizer:
    """索引优化器"""
    
    @staticmethod
    def analyze_slow_queries():
        """分析慢查询"""
        from django.db import connection
        
        with connection.cursor() as cursor:
            # SQLite查询计划分析
            cursor.execute("EXPLAIN QUERY PLAN SELECT * FROM contract_contract WHERE party_b = '供应商'")
            plan = cursor.fetchall()
            
            for row in plan:
                print(row)
    
    @staticmethod
    def recommend_indexes():
        """推荐索引"""
        recommendations = [
            # 单字段索引
            "CREATE INDEX idx_contract_code ON contract_contract(contract_code)",
            "CREATE INDEX idx_party_b ON contract_contract(party_b)",
            "CREATE INDEX idx_signing_date ON contract_contract(signing_date)",
            
            # 复合索引
            "CREATE INDEX idx_project_type ON contract_contract(project_id, file_positioning)",
            "CREATE INDEX idx_procurement_signing ON contract_contract(procurement_id, signing_date)",
            
            # 唯一索引
            "CREATE UNIQUE INDEX idx_payment_code ON payment_payment(payment_code)",
        ]
        
        return recommendations
    
    @staticmethod
    def create_missing_indexes():
        """创建缺失的索引"""
        from django.db import connection
        
        recommendations = IndexOptimizer.recommend_indexes()
        
        with connection.cursor() as cursor:
            for sql in recommendations:
                try:
                    cursor.execute(sql)
                    print(f"创建索引成功: {sql}")
                except Exception as e:
                    print(f"创建索引失败: {sql}, 错误: {e}")
```

### 5.2 缓存优化

#### 5.2.1 Django缓存配置

```python
# settings.py
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'unique-snowflake',
        'TIMEOUT': 300,  # 5分钟
        'OPTIONS': {
            'MAX_ENTRIES': 1000,
            'CULL_FREQUENCY': 3,
        }
    },
    'statistics': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'stats-cache',
        'TIMEOUT': 1800,  # 30分钟
    }
}

# 缓存装饰器
from django.core.cache import cache
from functools import wraps

def cache_result(timeout=300, cache_key_prefix=''):
    """缓存结果装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 生成缓存键
            cache_key = f"{cache_key_prefix}:{func.__name__}:{hash(str(args) + str(kwargs))}"
            
            # 尝试从缓存获取
            result = cache.get(cache_key)
            if result is not None:
                return result
            
            # 执行函数并缓存结果
            result = func(*args, **kwargs)
            cache.set(cache_key, result, timeout)
            
            return result
        return wrapper
    return decorator

# 使用示例
@cache_result(timeout=600, cache_key_prefix='stats')
def get_project_statistics(project_code):
    """获取项目统计（带缓存）"""
    project = Project.objects.get(project_code=project_code)
    return project.get_statistics()
```

#### 5.2.2 智能缓存策略

```python
class SmartCache:
    """智能缓存管理器"""
    
    @staticmethod
    def get_with_fallback(cache_key, fallback_func, timeout=300):
        """带回退函数的缓存获取"""
        result = cache.get(cache_key)
        
        if result is None:
            result = fallback_func()
            cache.set(cache_key, result, timeout)
        
        return result
    
    @staticmethod
    def invalidate_related_cache(obj):
        """清除相关缓存"""
        # 清除对象相关的缓存
        class_name = obj.__class__.__name__.lower()
        obj_id = getattr(obj, obj.__class__._meta.pk.name)
        
        # 清除列表缓存
        cache.delete(f"{class_name}_list")
        
        # 清除详情缓存
        cache.delete(f"{class_name}_detail_{obj_id}")
        
        # 清除统计缓存
        cache.delete(f"{class_name}_stats")
        
        # 如果是合同，清除项目统计缓存
        if class_name == 'contract' and hasattr(obj, 'project'):
            cache.delete(f"project_stats_{obj.project.project_code}")
    
    @staticmethod
    def warm_up_cache():
        """预热缓存"""
        # 预加载常用数据
        projects = Project.objects.all()
        for project in projects:
            # 预加载项目统计
            project.get_statistics()
            
            # 预加载项目合同
            cache.set(
                f"project_contracts_{project.project_code}",
                list(project.contracts.values('contract_code', 'contract_name')),
                1800
            )
```

---

## 6. 错误处理与日志

### 6.1 异常处理最佳实践

#### 6.1.1 自定义异常类

```python
class ProcurementSystemException(Exception):
    """系统基础异常类"""
    
    def __init__(self, message, error_code=None, details=None):
        self.message = message
        self.error_code = error_code
        self.details = details or {}
        super().__init__(self.message)

class ValidationException(ProcurementSystemException):
    """数据验证异常"""
    pass

class BusinessException(ProcurementSystemException):
    """业务规则异常"""
    pass

class ImportException(ProcurementSystemException):
    """数据导入异常"""
    pass

class NotFoundException(ProcurementSystemException):
    """资源未找到异常"""
    pass
```

#### 6.1.2 异常处理模式

```python
class ExceptionHandler:
    """异常处理器"""
    
    @staticmethod
    def handle_import_exception(func):
        """导入异常处理装饰器"""
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except ValidationError as e:
                logger.error(f"数据验证失败: {str(e)}")
                raise ImportException("数据验证失败", details={'validation_errors': e.messages})
            
            except FileNotFoundError:
                logger.error("导入文件不存在")
                raise ImportException("文件不存在")
            
            except pd.errors.EmptyDataError:
                logger.error("导入文件为空")
                raise ImportException("文件为空")
            
            except Exception as e:
                logger.exception(f"导入过程中发生未知错误: {str(e)}")
                raise ImportException(f"导入失败: {str(e)}")
        
        return wrapper
    
    @staticmethod
    def handle_business_exception(func):
        """业务异常处理装饰器"""
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except BusinessException as e:
                logger.warning(f"业务规则违反: {e.message}")
                return {'success': False, 'message': e.message, 'error_code': e.error_code}
            
            except NotFoundException as e:
                logger.warning(f"资源未找到: {e.message}")
                return {'success': False, 'message': e.message, 'error_code': 'NOT_FOUND'}
            
            except Exception as e:
                logger.exception(f"业务处理失败: {str(e)}")
                return {'success': False, 'message': '系统错误', 'error_code': 'SYSTEM_ERROR'}
        
        return wrapper
```

### 6.2 日志配置最佳实践

#### 6.2.1 日志配置

```python
# settings.py
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
        'detailed': {
            'format': '{levelname} {asctime} [{name}:{lineno}] {process:d} {thread:d} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': 'logs/procurement.log',
            'maxBytes': 10*1024*1024,  # 10MB
            'backupCount': 5,
            'formatter': 'detailed',
        },
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
        'error_file': {
            'level': 'ERROR',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': 'logs/procurement_error.log',
            'maxBytes': 10*1024*1024,
            'backupCount': 5,
            'formatter': 'detailed',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': True,
        },
        'procurement': {
            'handlers': ['console', 'file', 'error_file'],
            'level': 'DEBUG',
            'propagate': True,
        },
        'contract': {
            'handlers': ['console', 'file', 'error_file'],
            'level': 'DEBUG',
            'propagate': True,
        },
    },
}
```

#### 6.2.2 日志使用规范

```python
import logging

logger = logging.getLogger(__name__)

class ContractService:
    """合同服务类"""
    
    def create_contract(self, contract_data):
        """创建合同"""
        logger.info(f"开始创建合同: {contract_data.get('contract_code')}")
        
        try:
            contract = Contract.objects.create(**contract_data)
            logger.info(f"合同创建成功: {contract.contract_code}")
            return contract
            
        except ValidationError as e:
            logger.error(f"合同创建失败 - 验证错误: {e.messages}")
            raise
        
        except Exception as e:
            logger.exception(f"合同创建失败 - 未知错误: {str(e)}")
            raise
    
    def update_contract_status(self, contract_code, status):
        """更新合同状态"""
        logger.debug(f"更新合同状态: {contract_code} -> {status}")
        
        try:
            contract = Contract.objects.get(contract_code=contract_code)
            old_status = contract.status
            contract.status = status
            contract.save()
            
            logger.info(f"合同状态更新成功: {contract_code} {old_status} -> {status}")
            
        except Contract.DoesNotExist:
            logger.warning(f"合同不存在: {contract_code}")
            raise NotFoundException(f"合同不存在: {contract_code}")
        
        except Exception as e:
            logger.exception(f"合同状态更新失败: {contract_code}")
            raise
```

---

## 7. 测试最佳实践

### 7.1 单元测试

#### 7.1.1 模型测试

```python
from django.test import TestCase
from django.core.exceptions import ValidationError
from decimal import Decimal
from datetime import date

class ContractModelTest(TestCase):
    """合同模型测试"""
    
    def setUp(self):
        """测试数据准备"""
        self.project = Project.objects.create(
            project_code='PRJ2025001',
            project_name='测试项目'
        )
        
        self.procurement = Procurement.objects.create(
            procurement_code='GC2025001',
            project_name='测试采购'
        )
    
    def test_contract_creation(self):
        """测试合同创建"""
        contract = Contract.objects.create(
            contract_code='HT2025001',
            project=self.project,
            procurement=self.procurement,
            contract_name='测试合同',
            file_positioning='主合同',
            contract_amount=Decimal('500000.00')
        )
        
        self.assertEqual(contract.contract_code, 'HT2025001')
        self.assertEqual(contract.project, self.project)
        self.assertEqual(contract.procurement, self.procurement)
        self.assertEqual(contract.contract_amount, Decimal('500000.00'))
    
    def test_contract_validation(self):
        """测试合同验证"""
        # 测试补充协议必须关联主合同
        with self.assertRaises(ValidationError) as context:
            supplement = Contract(
                contract_code='HT2025001-01',
                contract_name='补充协议',
                file_positioning='补充协议',
                parent_contract=None  # 未关联主合同
            )
            supplement.full_clean()
        
        self.assertIn('补充协议必须关联主合同', str(context.exception))
    
    def test_payment_ratio_calculation(self):
        """测试付款比例计算"""
        contract = Contract.objects.create(
            contract_code='HT2025001',
            contract_name='测试合同',
            file_positioning='主合同',
            contract_amount=Decimal('500000.00')
        )
        
        # 创建付款记录
        Payment.objects.create(
            contract=contract,
            payment_amount=Decimal('250000.00'),
            payment_date=date(2025, 1, 15)
        )
        
        ratio = contract.get_payment_ratio()
        self.assertEqual(ratio, 50.0)
```

#### 7.1.2 视图测试

```python
from django.test import TestCase, Client
from django.urls import reverse
from django.contrib.auth.models import User

class ContractViewTest(TestCase):
    """合同视图测试"""
    
    def setUp(self):
        """测试数据准备"""
        self.client = Client()
        self.user = User.objects.create_user(
            username='testuser',
            password='testpass123'
        )
        self.client.login(username='testuser', password='testpass123')
        
        self.project = Project.objects.create(
            project_code='PRJ2025001',
            project_name='测试项目'
        )
        
        self.contract = Contract.objects.create(
            contract_code='HT2025001',
            project=self.project,
            contract_name='测试合同'
        )
    
    def test_contract_list_view(self):
        """测试合同列表视图"""
        url = reverse('contract_list')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'HT2025001')
        self.assertContains(response, '测试合同')
    
    def test_contract_detail_view(self):
        """测试合同详情视图"""
        url = reverse('contract_detail', kwargs={'contract_code': 'HT2025001'})
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'HT2025001')
        self.assertContains(response, '测试合同')
    
    def test_contract_search(self):
        """测试合同搜索功能"""
        url = reverse('contract_list')
        response = self.client.get(url, {'q': '测试'})
        
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'HT2025001')
```

### 7.2 集成测试

#### 7.2.1 数据导入测试

```python
from django.test import TestCase
from django.core.management import call_command
from io import StringIO
import tempfile
import os

class DataImportTest(TestCase):
    """数据导入集成测试"""
    
    def setUp(self):
        """测试数据准备"""
        self.project = Project.objects.create(
            project_code='PRJ2025001',
            project_name='测试项目'
        )
    
    def test_excel_import_success(self):
        """测试Excel导入成功"""
        # 创建测试Excel文件
        test_data = [
            ['合同编号', '合同名称', '合同类型', '合同金额'],
            ['HT2025001', '测试合同1', '主合同', '500000'],
            ['HT2025002', '测试合同2', '主合同', '300000'],
        ]
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            import csv
            writer = csv.writer(f)
            writer.writerows(test_data)
            temp_file = f.name
        
        try:
            # 执行导入命令
            out = StringIO()
            call_command(
                'import_excel',
                temp_file,
                '--module', 'contract',
                stdout=out,
                stderr=out
            )
            
            # 验证导入结果
            self.assertEqual(Contract.objects.count(), 2)
            
            contract1 = Contract.objects.get(contract_code='HT2025001')
            self.assertEqual(contract1.contract_name, '测试合同1')
            self.assertEqual(contract1.contract_amount, 500000)
        
        finally:
            # 清理临时文件
            os.unlink(temp_file)
    
    def test_wide_table_conversion(self):
        """测试宽表转换"""
        # 创建测试宽表数据
        wide_data = {
            '合同编号': ['HT2025001', 'HT2025002'],
            '2025年1月': [100000, 50000],
            '2025年2月': [150000, 75000],
            '2025年3月': [200000, 100000],
        }
        
        df = pd.DataFrame(wide_data)
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.xlsx', delete=False) as f:
            df.to_excel(f.name, index=False)
            temp_file = f.name
        
        try:
            # 执行宽表转换导入
            out = StringIO()
            call_command(
                'import_excel',
                temp_file,
                '--module', 'payment',
                '--mode', 'wide',
                stdout=out,
                stderr=out
            )
            
            # 验证转换结果
            self.assertEqual(Payment.objects.count(), 6)  # 2个合同 × 3个月
            
            # 验证数据正确性
            payment1 = Payment.objects.filter(
                contract__contract_code='HT2025001',
                payment_date=date(2025, 1, 1)
            ).first()
            self.assertEqual(payment1.payment_amount, 100000)
        
        finally:
            os.unlink(temp_file)
```

### 7.3 性能测试

#### 7.3.1 查询性能测试

```python
from django.test import TestCase
from django.test.utils import override_settings
from django.db import connection
import time

class PerformanceTest(TestCase):
    """性能测试"""
    
    def setUp(self):
        """创建大量测试数据"""
        # 创建1000个项目
        projects = [
            Project(
                project_code=f'PRJ2025{i:04d}',
                project_name=f'测试项目{i}'
            )
            for i in range(1, 1001)
        ]
        Project.objects.bulk_create(projects)
        
        # 为每个项目创建5个合同
        contracts = []
        for i, project in enumerate(projects):
            for j in range(1, 6):
                contracts.append(Contract(
                    contract_code=f'HT2025{i:04d}{j:02d}',
                    project=project,
                    contract_name=f'测试合同{i}-{j}',
                    contract_amount=100000 + j * 10000
                ))
        Contract.objects.bulk_create(contracts)
    
    def test_query_performance_with_select_related(self):
        """测试select_related优化效果"""
        # 未优化的查询
        start_time = time.time()
        contracts = Contract.objects.all()[:100]
        for contract in contracts:
            project_name = contract.project.project_name  # N+1查询
        unoptimized_time = time.time() - start_time
        
        # 优化的查询
        start_time = time.time()
        contracts = Contract.objects.select_related('project').all()[:100]
        for contract in contracts:
            project_name = contract.project.project_name  # 无额外查询
        optimized_time = time.time() - start_time
        
        # 优化后的查询应该更快
        self.assertLess(optimized_time, unoptimized_time)
        print(f"未优化时间: {unoptimized_time:.3f}s, 优化时间: {optimized_time:.3f}s")
    
    def test_batch_operations_performance(self):
        """测试批量操作性能"""
        # 单个操作
        start_time = time.time()
        for contract in Contract.objects.all()[:100]:
            contract.updated_by = 'test_user'
            contract.save()
        individual_time = time.time() - start_time
        
        # 批量操作
        start_time = time.time()
        Contract.objects.filter(pk__in=range(1, 101)).update(updated_by='test_user')
        batch_time = time.time() - start_time
        
        # 批量操作应该更快
        self.assertLess(batch_time, individual_time)
        print(f"单个操作时间: {individual_time:.3f}s, 批量操作时间: {batch_time:.3f}s")
```

---

## 8. 常见陷阱与解决方案

### 8.1 数据库陷阱

#### 8.1.1 N+1查询问题

**问题描述：**
```python
# 错误示例：会产生N+1查询
contracts = Contract.objects.all()
for contract in contracts:
    project_name = contract.project.project_name  # 每次都查询数据库
```

**解决方案：**
```python
# 正确示例：使用select_related预加载
contracts = Contract.objects.select_related('project').all()
for contract in contracts:
    project_name = contract.project.project_name  # 无额外查询
```

#### 8.1.2 事务使用不当

**问题描述：**
```python
# 错误示例：缺少事务保护
def transfer_payment(payment_id, new_contract_id):
    payment = Payment.objects.get(pk=payment_id)
    payment.contract_id = new_contract_id
    payment.save()  # 如果这里失败，数据不一致
```

**解决方案：**
```python
# 正确示例：使用事务保护
from django.db import transaction

@transaction.atomic
def transfer_payment(payment_id, new_contract_id):
    payment = Payment.objects.get(pk=payment_id)
    payment.contract_id = new_contract_id
    payment.save()  # 事务保证原子性
```

### 8.2 内存陷阱

#### 8.2.1 大数据集内存溢出

**问题描述：**
```python
# 错误示例：一次性加载所有数据到内存
all_payments = Payment.objects.all()  # 可能导致内存溢出
for payment in all_payments:
    process_payment(payment)
```

**解决方案：**
```python
# 正确示例：使用分页或迭代器
def process_all_payments():
    page_size = 1000
    offset = 0
    
    while True:
        payments = Payment.objects.all()[offset:offset+page_size]
        if not payments:
            break
        
        for payment in payments:
            process_payment(payment)
        
        offset += page_size

# 或者使用迭代器
def process_all_payments_iterator():
    for payment in Payment.objects.iterator():
        process_payment(payment)
```

#### 8.2.2 缓存滥用

**问题描述：**
```python
# 错误示例：缓存过多数据
def get_all_contracts():
    cache_key = 'all_contracts'
    contracts = cache.get(cache_key)
    if contracts is None:
        contracts = list(Contract.objects.all())  # 可能很大
        cache.set(cache_key, contracts, 3600)  # 占用大量内存
    return contracts
```

**解决方案：**
```python
# 正确示例：缓存查询结果或分页数据
def get_contract_list(page=1):
    cache_key = f'contract_list_page_{page}'
    contracts = cache.get(cache_key)
    if contracts is None:
        contracts = list(Contract.objects.all()[(page-1)*20:page*20])
        cache.set(cache_key, contracts, 600)  # 较小的数据量
    return contracts
```

### 8.3 并发陷阱

#### 8.3.1 竞态条件

**问题描述：**
```python
# 错误示例：存在竞态条件
def generate_payment_code(contract):
    # 查询最大序号
    max_seq = Payment.objects.filter(
        contract=contract
    ).aggregate(max_seq=Max('payment_code__regex__extract=r'(\d+)$'))['max_seq'] or 0
    
    # 生成新编号（其他进程可能在这里插入相同编号）
    new_code = f"{contract.contract_code}-FK-{max_seq + 1:03d}"
    
    # 创建付款记录（可能冲突）
    payment = Payment.objects.create(
        payment_code=new_code,
        contract=contract
    )
    return payment
```

**解决方案：**
```python
# 正确示例：使用数据库锁
from django.db import transaction

@transaction.atomic
def generate_payment_code(contract):
    # 锁定相关记录
    locked_contract = Contract.objects.select_for_update().get(pk=contract.pk)
    
    # 在事务中查询和创建
    max_seq = Payment.objects.filter(
        contract=locked_contract
    ).aggregate(max_seq=Max('payment_code__regex__extract=r'(\d+)$'))['max_seq'] or 0
    
    new_code = f"{locked_contract.contract_code}-FK-{max_seq + 1:03d}"
    
    payment = Payment.objects.create(
        payment_code=new_code,
        contract=locked_contract
    )
    return payment
```

### 8.4 业务逻辑陷阱

#### 8.4.1 浮点数精度问题

**问题描述：**
```python
# 错误示例：使用float处理金额
def calculate_total_amount(amounts):
    total = 0.0
    for amount in amounts:
        total += amount  # 可能产生精度误差
    return total
```

**解决方案：**
```python
# 正确示例：使用Decimal处理金额
from decimal import Decimal

def calculate_total_amount(amounts):
    total = Decimal('0')
    for amount in amounts:
        total += Decimal(str(amount))
    return total
```

#### 8.4.2 时区处理问题

**问题描述：**
```python
# 错误示例：时区处理不当
from datetime import datetime

def get_today_payments():
    today = datetime.now().date()  # 使用系统时区
    return Payment.objects.filter(payment_date=today)
```

**解决方案：**
```python
# 正确示例：使用Django的时区工具
from django.utils import timezone

def get_today_payments():
    today = timezone.now().date()  # 使用配置的时区
    return Payment.objects.filter(payment_date=today)
```

---

## 9. 开发工具与技巧

### 9.1 开发环境配置

#### 9.1.1 VS Code配置

```json
// .vscode/settings.json
{
    "python.defaultInterpreterPath": "./venv/Scripts/python.exe",
    "python.linting.enabled": true,
    "python.linting.pylintEnabled": true,
    "python.formatting.provider": "black",
    "python.formatting.blackArgs": ["--line-length", "88"],
    "python.testing.pytestEnabled": true,
    "python.testing.pytestArgs": ["-v"],
    "files.exclude": {
        "**/__pycache__": true,
        "**/*.pyc": true,
        "**/migrations/": true
    }
}
```

#### 9.1.2 调试配置

```python
# settings.py
if DEBUG:
    # 开发环境配置
    INSTALLED_APPS += ['debug_toolbar']
    MIDDLEWARE += ['debug_toolbar.middleware.DebugToolbarMiddleware']
    INTERNAL_IPS = ['127.0.0.1']

# 调试工具栏配置
import debug_toolbar
```

### 9.2 代码质量工具

#### 9.2.1 代码格式化

```bash
# 安装代码格式化工具
pip install black isort flake8

# 格式化代码
black .
isort .

# 检查代码质量
flake8 .
```

#### 9.2.2 代码检查配置

```ini
# setup.cfg
[flake8]
max-line-length = 88
exclude = migrations, venv
ignore = E203, W503
per-file-ignores =
    __init__.py: F401

[isort]
profile = black
multi_line_output = 3
line_length = 88
known_first_party = procurement, contract, payment, settlement, supplier_eval, project
```

### 9.3 自动化脚本

#### 9.3.1 数据库管理脚本

```python
# scripts/db_management.py
import os
import django
from django.conf import settings
from django.core.management import execute_from_command_line

def setup_django():
    """设置Django环境"""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    django.setup()

def reset_database():
    """重置数据库"""
    setup_django()
    
    # 删除数据库文件
    db_path = settings.DATABASES['default']['NAME']
    if os.path.exists(db_path):
        os.remove(db_path)
        print(f"数据库文件已删除: {db_path}")
    
    # 重新创建迁移
    execute_from_command_line(['manage.py', 'makemigrations'])
    execute_from_command_line(['manage.py', 'migrate'])
    
    # 创建超级用户
    execute_from_command_line([
        'manage.py', 'createsuperuser',
        '--username', 'admin',
        '--email', 'admin@example.com',
        '--noinput'
    ])
    
    print("数据库重置完成")

if __name__ == '__main__':
    reset_database()
```

#### 9.3.2 部署脚本

```python
# scripts/deploy.py
import os
import subprocess
import shutil

def deploy_application():
    """部署应用"""
    print("开始部署应用...")
    
    # 1. 备份数据库
    backup_database()
    
    # 2. 更新代码
    update_code()
    
    # 3. 安装依赖
    install_dependencies()
    
    # 4. 数据库迁移
    migrate_database()
    
    # 5. 收集静态文件
    collect_static()
    
    # 6. 重启服务
    restart_service()
    
    print("应用部署完成")

def backup_database():
    """备份数据库"""
    backup_dir = 'backups'
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_file = os.path.join(backup_dir, f'db_backup_{timestamp}.sqlite3')
    
    shutil.copy2('db.sqlite3', backup_file)
    print(f"数据库已备份到: {backup_file}")

def update_code():
    """更新代码"""
    # 这里可以添加从版本控制系统拉取代码的逻辑
    print("代码更新完成")

def install_dependencies():
    """安装依赖"""
    subprocess.run(['pip', 'install', '-r', 'requirements.txt'])
    print("依赖安装完成")

def migrate_database():
    """数据库迁移"""
    subprocess.run(['python', 'manage.py', 'migrate'])
    print("数据库迁移完成")

def collect_static():
    """收集静态文件"""
    subprocess.run(['python', 'manage.py', 'collectstatic', '--noinput'])
    print("静态文件收集完成")

def restart_service():
    """重启服务"""
    # 这里可以添加重启服务的逻辑
    print("服务重启完成")

if __name__ == '__main__':
    deploy_application()
```

---

## 10. 总结

### 10.1 开发实践要点

1. **遵循编码规范**：保持代码一致性和可读性
2. **合理使用设计模式**：提高代码的可维护性和扩展性
3. **重视性能优化**：避免常见的性能陷阱
4. **完善错误处理**：提高系统的健壮性
5. **编写充分测试**：确保代码质量和功能正确性

### 10.2 最佳实践总结

| 实践领域 | 关键要点 | 工具/技术 |
|----------|----------|-----------|
| **代码规范** | PEP 8、命名规范、文档字符串 | black、isort、flake8 |
| **设计模式** | 抽象基类、策略模式、工厂方法 | Django ORM、Python OOP |
| **性能优化** | 查询优化、缓存策略、批量操作 | select_related、Redis |
| **错误处理** | 自定义异常、日志记录、事务管理 | Django logging、事务装饰器 |
| **测试** | 单元测试、集成测试、性能测试 | Django TestCase、pytest |
| **数据处理** | Excel处理、数据验证、批量导入 | pandas、openpyxl |
| **部署运维** | 自动化脚本、监控、备份 | shell脚本、Django commands |

### 10.3 持续改进建议

1. **定期代码审查**：确保代码质量和规范遵守
2. **性能监控**：定期检查和优化慢查询
3. **安全审计**：定期进行安全检查和更新
4. **文档维护**：及时更新技术文档和用户手册
5. **技术债务管理**：定期重构和优化代码

### 10.4 团队协作

1. **统一开发环境**：确保团队成员使用一致的开发环境
2. **代码版本控制**：合理使用Git分支和合并策略
3. **知识分享**：定期组织技术分享和培训
4. **问题追踪**：使用Issue管理系统跟踪问题和任务
5. **持续集成**：建立自动化测试和部署流程

---

**文档状态：** ✅ 完成  
**维护责任人：** 技术负责人  
**更新频率：** 根据技术发展及时更新  
**相关文档：** [系统架构分析文档](系统架构分析文档.md)、[数据模型使用手册](数据模型使用手册.md)