# 付款编号生成规则说明

**修改日期：** 2025-10-21  
**修改内容：** 优化付款编号自动生成逻辑

---

## 1. 新规则说明

### 1.1 编号格式

```
[合同序号]-FK-[序号]
```

- **合同序号**：优先使用 `contract.contract_sequence`，如果为空则使用 `contract.contract_code`
- **FK**：固定标识符，表示"付款"
- **序号**：3位数字（001, 002, 003...），按付款日期排序生成

### 1.2 序号生成规则

序号按照**付款日期**从早到晚排序：
- 同一个合同的最早付款日期为 **001**
- 之后的付款按日期依次递增
- 同一天的多笔付款按创建时间排序

### 1.3 示例

假设合同序号为 `BHHY-NH-102`，有以下付款记录：

| 付款日期 | 付款金额 | 生成编号 |
|---------|---------|----------|
| 2025-03-15 | 100,000 | BHHY-NH-102-FK-001 |
| 2025-06-20 | 150,000 | BHHY-NH-102-FK-002 |
| 2025-09-10 | 200,000 | BHHY-NH-102-FK-003 |

如果后来又新增一笔 2025-05-01 的付款：

| 付款日期 | 付款金额 | 生成编号 |
|---------|---------|----------|
| 2025-03-15 | 100,000 | BHHY-NH-102-FK-001 |
| **2025-05-01** | **80,000** | **BHHY-NH-102-FK-002** |
| 2025-06-20 | 150,000 | BHHY-NH-102-FK-003 |
| 2025-09-10 | 200,000 | BHHY-NH-102-FK-004 |

---

## 2. 与旧规则的对比

### 2.1 旧规则（修改前）

```python
# 旧逻辑
sequence = existing_payments.count() + 1
payment_code = f"{contract.contract_code}-FK-{sequence:03d}"
```

**问题：**
- 使用合同编号而非合同序号
- 序号简单递增，不考虑付款日期
- 如果删除某笔付款，会导致序号不连续

### 2.2 新规则（修改后）

```python
# 新逻辑
contract_identifier = contract.contract_sequence or contract.contract_code
# 按付款日期排序计算序号
sequence = 计算该付款在按日期排序后的位置
payment_code = f"{contract_identifier}-FK-{sequence:03d}"
```

**改进：**
- 优先使用合同序号（更简洁）
- 序号反映真实的付款时间顺序
- 逻辑更符合业务实际需求

---

## 3. 数据迁移说明

### 3.1 现有数据处理

**重要：现有的付款记录不会自动更新编号**

- 旧数据保持原有编号不变
- 新创建的付款记录使用新规则生成编号
- 系统会同时存在两种格式的编号（过渡期正常现象）

### 3.2 编号格式示例

**旧格式（历史数据）：**
```
TJ-JTBB20250312183-FK-215
```

**新格式（新建数据）：**
```
BHHY-NH-102-FK-001
```

### 3.3 如何统一编号格式（可选）

如果需要将所有历史数据统一为新格式，可以执行以下操作：

**注意：此操作会修改所有付款编号，建议先备份数据库！**

```python
# 示例脚本（需要根据实际情况调整）
from payment.models import Payment

payments = Payment.objects.all().order_by('contract', 'payment_date', 'created_at')

for payment in payments:
    # 重新生成编号
    old_code = payment.payment_code
    payment.payment_code = ''  # 清空以触发自动生成
    payment.save()
    print(f"更新: {old_code} -> {payment.payment_code}")
```

**风险提示：**
- 编号变更可能影响已导出的报表
- 建议在系统使用初期或维护窗口执行
- 必须先备份数据库

---

## 4. 技术实现

### 4.1 核心代码

文件位置：`payment/models.py`

```python
def _generate_payment_code(self):
    """
    生成付款编号：合同序号-FK-序号
    序号按付款日期排序，最早的付款为001，之后依次类推
    """
    if not self.contract:
        raise ValidationError('生成付款编号需要关联合同')
    
    if not self.payment_date:
        raise ValidationError('生成付款编号需要提供付款日期')
    
    # 使用合同序号，如果没有则使用合同编号
    contract_identifier = self.contract.contract_sequence or self.contract.contract_code
    
    # 查询该合同下所有付款记录，按付款日期排序
    existing_payments = Payment.objects.filter(
        contract=self.contract
    ).order_by('payment_date', 'created_at')
    
    # 计算当前付款在按日期排序后的序号
    sequence = 1
    for payment in existing_payments:
        if self.pk and payment.pk == self.pk:
            continue
        if payment.payment_date < self.payment_date:
            sequence += 1
        elif payment.payment_date == self.payment_date and payment.created_at < self.created_at:
            sequence += 1
    
    return f"{contract_identifier}-FK-{sequence:03d}"
```

### 4.2 触发时机

付款编号在以下情况下自动生成：
1. 新建付款记录时，如果 `payment_code` 为空
2. 调用 `save()` 方法时自动执行

### 4.3 前置条件

生成编号需要满足：
- 必须关联合同（`contract` 字段不为空）
- 必须有付款日期（`payment_date` 字段不为空）

---

## 5. 测试验证

### 5.1 测试脚本

项目根目录下提供了以下测试脚本：

1. **test_payment_code_generation.py** - 基础测试
2. **test_payment_with_data.py** - 现有数据测试
3. **test_new_payment_creation.py** - 新建付款测试

### 5.2 运行测试

```bash
# 测试基础逻辑
python test_payment_code_generation.py

# 测试现有数据
python test_payment_with_data.py

# 测试新建付款
python test_new_payment_creation.py
```

---

## 6. 常见问题

### Q1: 为什么使用合同序号而不是合同编号？

**A:** 合同序号通常更简洁、更具业务意义。例如：
- 合同编号：`TJ-JTBB20250312183`（冗长）
- 合同序号：`BHHY-NH-102`（简洁明了）

如果合同没有设置序号，系统会自动使用合同编号。

### Q2: 旧数据的编号会自动更新吗？

**A:** 不会。现有付款记录保持原有编号不变，只有新建的付款记录才使用新规则。

### Q3: 如果删除某笔付款，编号会重新排序吗？

**A:** 不会。编号在创建时就已固定，删除其他付款不会影响现有编号。但新增付款时，会根据当时的付款日期计算正确的序号位置。

### Q4: 同一天有多笔付款怎么排序？

**A:** 按创建时间（`created_at`）排序，先创建的排在前面。

### Q5: 可以手动指定付款编号吗？

**A:** 可以。在创建付款时手动填写 `payment_code` 字段即可，系统不会覆盖已有的编号。

---

## 7. 后续建议

1. **监控过渡期**：观察新旧格式混存的情况
2. **用户培训**：告知用户编号格式已优化
3. **数据清理**：择机统一历史数据编号格式（可选）
4. **报表调整**：确认报表系统能正确处理新格式

---

## 8. 修订历史

| 版本 | 日期 | 修订内容 | 修订人 |
|-----|------|---------|-------|
| v1.0 | 2025-10-21 | 初始版本，优化付款编号生成逻辑 | Kilo Code |

---

**文档状态：** ✅ 已完成  
**下一步：** 在实际使用中验证新逻辑的稳定性