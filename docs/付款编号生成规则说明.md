y# 付款编号生成规则说明

**修改日期：** 2025-10-21  
**修改内容：** 优化付款编号自动生成逻辑

---

## 1. 新规则说明

### 1.1 编号格式

```
[合同序号]-FK-[序号]
```

- **合同序号**：优先使用 `contract.contract_sequence`，如果为空则使用 `contract.contract_code`
- **FK**：固定标识符，表示"付款"
- **序号**：3位数字（001, 002, 003...），按付款日期排序生成

### 1.2 序号生成规则

序号按照**付款日期**从早到晚排序：
- 同一个合同的最早付款日期为 **001**
- 之后的付款按日期依次递增
- 同一天的多笔付款按创建时间排序

### 1.3 示例

假设合同序号为 `BHHY-NH-102`，有以下付款记录：

| 付款日期 | 付款金额 | 生成编号 |
|---------|---------|----------|
| 2025-03-15 | 100,000 | BHHY-NH-102-FK-001 |
| 2025-06-20 | 150,000 | BHHY-NH-102-FK-002 |
| 2025-09-10 | 200,000 | BHHY-NH-102-FK-003 |

如果后来又新增一笔 2025-05-01 的付款：

| 付款日期 | 付款金额 | 生成编号 |
|---------|---------|----------|
| 2025-03-15 | 100,000 | BHHY-NH-102-FK-001 |
| **2025-05-01** | **80,000** | **BHHY-NH-102-FK-002** |
| 2025-06-20 | 150,000 | BHHY-NH-102-FK-003 |
| 2025-09-10 | 200,000 | BHHY-NH-102-FK-004 |

---

## 2. 与旧规则的对比

### 2.1 旧规则（修改前）

```python
# 旧逻辑
sequence = existing_payments.count() + 1
payment_code = f"{contract.contract_code}-FK-{sequence:03d}"
```

**问题：**
- 使用合同编号而非合同序号
- 序号简单递增，不考虑付款日期
- 如果删除某笔付款，会导致序号不连续

### 2.2 新规则（修改后）

```python
# 新逻辑
contract_identifier = contract.contract_sequence or contract.contract_code
# 按付款日期排序计算序号
sequence = 计算该付款在按日期排序后的位置
payment_code = f"{contract_identifier}-FK-{sequence:03d}"
```

**改进：**
- 优先使用合同序号（更简洁）
- 序号反映真实的付款时间顺序
- 逻辑更符合业务实际需求

---

## 3. 数据迁移说明

### 3.1 现有数据处理

**重要：现有的付款记录不会自动更新编号**

- 旧数据保持原有编号不变
- 新创建的付款记录使用新规则生成编号
- 系统会同时存在两种格式的编号（过渡期正常现象）

### 3.2 编号格式示例

**旧格式（历史数据）：**
```
TJ-JTBB20250312183-FK-215
```

**新格式（新建数据）：**
```
BHHY-NH-102-FK-001
```

### 3.3 如何统一编号格式（可选）

如果需要将所有历史数据统一为新格式，可以执行以下操作：

**注意：此操作会修改所有付款编号，建议先备份数据库！**

```python
# 示例脚本（需要根据实际情况调整）
from payment.models import Payment

payments = Payment.objects.all().order_by('contract', 'payment_date', 'created_at')

for payment in payments:
    # 重新生成编号
    old_code = payment.payment_code
    payment.payment_code = ''  # 清空以触发自动生成
    payment.save()
    print(f"更新: {old_code} -> {payment.payment_code}")
```

**风险提示：**
- 编号变更可能影响已导出的报表
- 建议在系统使用初期或维护窗口执行
- 必须先备份数据库

---

## 4. 技术实现

### 4.1 核心代码

#### 4.1.1 模型层（payment/models.py）

```python
def _generate_payment_code(self):
    """
    生成付款编号：合同序号-FK-序号
    序号按付款日期排序，最早的付款为001，之后依次类推
    """
    if not self.contract:
        raise ValidationError('生成付款编号需要关联合同')
    
    if not self.payment_date:
        raise ValidationError('生成付款编号需要提供付款日期')
    
    # 使用合同序号，如果没有则使用合同编号
    contract_identifier = self.contract.contract_sequence or self.contract.contract_code
    
    # 查询该合同下所有付款记录，按付款日期排序
    existing_payments = Payment.objects.filter(
        contract=self.contract
    ).order_by('payment_date', 'created_at')
    
    # 计算当前付款在按日期排序后的序号
    sequence = 1
    for payment in existing_payments:
        if self.pk and payment.pk == self.pk:
            continue
        if payment.payment_date < self.payment_date:
            sequence += 1
        elif payment.payment_date == self.payment_date and payment.created_at < self.created_at:
            sequence += 1
    
    return f"{contract_identifier}-FK-{sequence:03d}"
```

#### 4.1.2 导入命令（procurement/management/commands/import_excel.py）

**长表导入**（第828行起）：
```python
def _import_payment_long(self, row, conflict_mode='update'):
    # ...
    # 如果付款编号为空，将在模型的save方法中自动生成
    if payment_code:
        obj, created = Payment.objects.update_or_create(...)
    else:
        # 创建新记录，会自动调用模型的_generate_payment_code
        obj = Payment.objects.create(...)
```

**宽表导入**（第891行起）：
```python
def _import_payment_wide(self, row, seq, group_id, conflict_mode='update'):
    # ...
    # 创建临时对象来生成符合新规则的编号
    temp_payment = Payment(
        contract=contract,
        payment_amount=amount,
        payment_date=payment_date,
        settlement_amount=settlement_amount,
        is_settled=is_settled,
    )
    # 调用生成方法获取编号
    payment_code = temp_payment._generate_payment_code()
    
    # 使用生成的编号创建/更新记录
    obj, created = Payment.objects.update_or_create(
        payment_code=payment_code,
        defaults={...}
    )
```

**重要说明：** 宽表导入已更新为使用新的编号生成逻辑，不再使用简单的递增序号。

### 4.2 触发时机

付款编号在以下情况下自动生成：
1. 手动新建付款记录时，如果 `payment_code` 为空
2. 长表导入时，如果CSV中的付款编号字段为空
3. 宽表导入时，自动调用新逻辑生成编号
4. 调用 `save()` 方法时自动执行

### 4.3 前置条件

生成编号需要满足：
- 必须关联合同（`contract` 字段不为空）
- 必须有付款日期（`payment_date` 字段不为空）

---

## 5. 导入文件处理

### 5.1 长表导入

**CSV格式示例：**
```csv
付款编号,关联合同编号,实付金额(元),付款日期,结算价（元）,是否办理结算
,HT2025001,100000,2025-03-15,,否
,HT2025001,150000,2025-06-20,,否
```

**说明：**
- 付款编号列可以为空，系统会自动生成
- 如果填写了付款编号，系统会使用填写的值（不建议手动填写）

### 5.2 宽表导入

**Excel格式示例：**
```
合同序号    | 结算价 | 是否已结算 | 2025年1月 | 2025年2月 | 2025年3月
BHHY-NH-102 | 500000 | 否        | 100000   | 150000   | 200000
```

**处理流程：**
1. 系统将宽表转换为长表格式
2. 按付款日期排序所有付款记录
3. 为每笔付款自动生成符合新规则的编号

**生成的付款记录：**
```
BHHY-NH-102-FK-001 | 100000 | 2025-01-01
BHHY-NH-102-FK-002 | 150000 | 2025-02-01
BHHY-NH-102-FK-003 | 200000 | 2025-03-01
```

## 6. 测试验证

### 6.1 测试脚本

项目根目录下提供了以下测试脚本：

1. **test_payment_code_generation.py** - 基础测试
2. **test_payment_with_data.py** - 现有数据测试
3. **test_new_payment_creation.py** - 新建付款测试

### 5.2 运行测试

```bash
# 测试基础逻辑
python test_payment_code_generation.py

# 测试现有数据
python test_payment_with_data.py

# 测试新建付款
python test_new_payment_creation.py
```

---

## 7. 常见问题

### Q1: 为什么使用合同序号而不是合同编号？

**A:** 合同序号通常更简洁、更具业务意义。例如：
- 合同编号：`TJ-JTBB20250312183`（冗长）
- 合同序号：`BHHY-NH-102`（简洁明了）

如果合同没有设置序号，系统会自动使用合同编号。

### Q2: 旧数据的编号会自动更新吗？

**A:** 不会。现有付款记录保持原有编号不变，只有新建的付款记录才使用新规则。

### Q3: 如果删除某笔付款，编号会重新排序吗？

**A:** 不会。编号在创建时就已固定，删除其他付款不会影响现有编号。但新增付款时，会根据当时的付款日期计算正确的序号位置。

### Q4: 同一天有多笔付款怎么排序？

**A:** 按创建时间（`created_at`）排序，先创建的排在前面。

### Q5: 可以手动指定付款编号吗？

**A:** 可以。在创建付款时手动填写 `payment_code` 字段即可，系统不会覆盖已有的编号。

---

### Q6: 导入文件时使用的是旧逻辑吗？

**A:** 不是。导入功能已经更新：
- 长表导入：如果付款编号为空，会使用新逻辑自动生成
- 宽表导入：已修改为调用新的编号生成方法
- 两种导入方式都会按付款日期排序生成编号

## 8. 后续建议

1. **监控过渡期**：观察新旧格式混存的情况
2. **用户培训**：告知用户编号格式已优化
3. **数据清理**：择机统一历史数据编号格式（可选）
4. **报表调整**：确认报表系统能正确处理新格式

---

## 9. 修订历史

| 版本 | 日期 | 修订内容 | 修订人 |
|-----|------|---------|-------|
| v1.0 | 2025-10-21 | 初始版本，优化付款编号生成逻辑 | Kilo Code |
| v1.1 | 2025-10-21 | 更新导入功能，宽表导入也使用新逻辑 | Kilo Code |

---

**文档状态：** ✅ 已完成  
**下一步：** 在实际使用中验证新逻辑的稳定性