# 归档监控页面改造 - 技术方案与实施计划

## 文档信息

- **创建日期**: 2025-01-10
- **最后更新**: 2025-01-10
- **作者**: 架构师模式
- **关联需求**: [归档监控页面完整需求文档.md](./归档监控页面完整需求文档.md)
- **状态**: ✅ 待审核

---

## 目录

1. [需求分析总结](#一需求分析总结)
2. [数据库查询策略](#二数据库查询策略)
3. [服务层设计](#三服务层设计)
4. [视图层设计](#四视图层设计)
5. [模板层设计](#五模板层设计)
6. [前端交互设计](#六前端交互设计)
7. [分阶段实施计划](#七分阶段实施计划)
8. [验收测试标准](#八验收测试标准)
9. [风险评估与应对](#九风险评估与应对)

---

## 一、需求分析总结

### 1.1 核心变更点

根据需求文档，本次改造的核心是**区分项目视图和个人视图**：

#### 项目视图
- **数据维度**: 以项目为单位统计
- **展示内容**: 项目列表 + 选定项目的趋势图和超期记录
- **全局筛选作用**: 
  - 选择具体项目 → 只显示该项目
  - 选择"全部项目" → 显示所有项目列表

#### 个人视图
- **数据维度**: 以经办人为单位统计
- **展示内容**: 经办人列表 + 所有经办人汇总的趋势图和超期记录
- **全局筛选作用**:
  - 选择具体项目 → 只显示在该项目中有业务的经办人
  - 选择"全部项目" → 显示所有经办人

### 1.2 关键技术挑战

1. **数据聚合复杂度**: 需要按项目或经办人分组计算平均周期、及时率等多维指标
2. **趋势图算法**: 全年度按半年分组，单年度按月分组，需要自动跳过无数据时间点
3. **超期记录分级**: 严重/中度/轻微/待归档四级分类逻辑
4. **性能优化**: 避免N+1查询，使用Django ORM的聚合和注解功能
5. **前后端数据传递**: 趋势图数据需要转换为JSON格式供Chart.js使用

---

## 二、数据库查询策略

### 2.1 核心查询原则

```python
# 原则1: 使用select_related避免N+1查询
Procurement.objects.select_related('project').filter(...)

# 原则2: 使用annotate进行数据库层聚合
queryset.annotate(
    archive_cycle=ExpressionWrapper(
        F('archive_date') - F('result_publicity_release_date'),
        output_field=fields.DurationField()
    )
)

# 原则3: 使用Avg、Count等聚合函数
queryset.aggregate(
    avg_cycle=Avg('archive_cycle'),
    on_time_count=Count('id', filter=Q(archive_cycle__lte=timedelta(days=40)))
)
```

### 2.2 项目视图查询策略

#### 获取项目概览列表

```python
def get_projects_archive_overview(year_filter=None, project_filter=None):
    """
    返回结构:
    {
        'summary': {
            'project_count': int,
            'procurement_archived': int,
            'procurement_total': int,
            'contract_archived': int,
            'contract_total': int,
            'overall_archive_rate': float
        },
        'projects': [
            {
                'project_code': str,
                'project_name': str,
                'procurement_count': int,
                'procurement_archived': int,
                'procurement_avg_cycle': float,
                'procurement_on_time_rate': float,
                'contract_count': int,
                'contract_archived': int,
                'contract_avg_cycle': float,
                'contract_on_time_rate': float,
                'overall_archive_rate': float
            }
        ]
    }
    """
    # 步骤1: 获取所有项目
    projects = Project.objects.all()
    if project_filter:
        projects = projects.filter(project_code=project_filter)
    
    # 步骤2: 为每个项目计算采购统计
    # 步骤3: 为每个项目计算合同统计
    # 步骤4: 计算综合归档率并排序
    # 详见实现细节
```

#### 性能优化要点

1. **避免循环查询**: 使用prefetch_related预加载关联数据
2. **数据库层计算**: 在数据库层完成周期计算和平均值计算
3. **批量处理**: 一次查询获取所有需要的数据，避免多次往返

### 2.3 个人视图查询策略

#### 获取经办人概览列表

```python
def get_persons_archive_overview(year_filter=None, project_filter=None):
    """
    返回结构: 类似项目视图，但数据维度是经办人
    """
    # 步骤1: 获取所有经办人名单
    handlers = set()
    handlers.update(
        Procurement.objects.filter(...).values_list('procurement_officer', flat=True).distinct()
    )
    handlers.update(
        Contract.objects.filter(...).values_list('contract_officer', flat=True).distinct()
    )
    
    # 步骤2: 为每个经办人计算统计数据
    # 步骤3: 计算负责的项目数
    # 详见实现细节
```

### 2.4 趋势图数据查询

#### 按半年分组（全年度模式）

```python
def _group_by_half_year(queryset):
    """
    输入: 包含business_year和business_month的queryset
    输出: [
        {'period': '2023-H1', 'avg_cycle': 35.2, 'count': 15},
        {'period': '2023-H2', 'avg_cycle': None, 'count': 0},  # 无数据时avg_cycle为None
        {'period': '2024-H1', 'avg_cycle': 28.5, 'count': 20}
    ]
    """
    trend_data = []
    years = queryset.values_list('business_year', flat=True).distinct().order_by('business_year')
    
    for year in years:
        # 上半年（1-6月）
        h1_data = queryset.filter(business_year=year, business_month__lte=6)
        h1_count = h1_data.count()
        h1_avg_cycle = h1_data.aggregate(avg=Avg('archive_cycle'))['avg']
        
        trend_data.append({
            'period': f'{year}-H1',
            'avg_cycle': h1_avg_cycle.days if h1_avg_cycle else None,
            'count': h1_count
        })
        
        # 下半年（7-12月）
        # 同理...
    
    return trend_data
```

#### 按月分组（单年度模式）

```python
def _group_by_month(queryset):
    """
    输入: 已筛选到特定年份的queryset
    输出: [
        {'period': '1月', 'avg_cycle': 32.1, 'count': 5},
        {'period': '2月', 'avg_cycle': None, 'count': 0},
        ...
    ]
    """
    trend_data = []
    for month in range(1, 13):
        month_data = queryset.filter(business_month=month)
        count = month_data.count()
        avg_cycle_timedelta = month_data.aggregate(avg=Avg('archive_cycle'))['avg']
        
        trend_data.append({
            'period': f'{month}月',
            'avg_cycle': avg_cycle_timedelta.days if avg_cycle_timedelta else None,
            'count': count
        })
    
    return trend_data
```

---

## 三、服务层设计

### 3.1 现有服务层分析

当前已存在 [`ArchiveStatisticsService`](project/services/monitors/archive_statistics.py:13) 类，包含以下方法：

- `get_project_statistics()`: 获取单个项目的统计数据
- `get_person_statistics()`: 获取单个经办人的统计数据
- `_calculate_procurement_statistics()`: 计算采购归档统计
- `_calculate_contract_statistics()`: 计算合同归档统计
- `_calculate_trend()`: 计算归档周期趋势
- `get_person_list()`: 获取经办人列表

### 3.2 需要新增的方法

#### 方法1: 获取项目维度概览

```python
def get_projects_archive_overview(self, year_filter=None, project_filter=None):
    """
    获取项目维度的归档概览
    
    Args:
        year_filter: str - 年度筛选（'all' 或 '2024'）
        project_filter: str or None - 项目编码
    
    Returns:
        dict: {
            'summary': {汇总统计},
            'projects': [{项目列表}]
        }
    """
```

**实现要点**:
1. 如果`project_filter`为None，返回所有项目的列表
2. 如果指定了`project_filter`，只返回该项目的数据
3. 每个项目需计算：采购统计、合同统计、综合归档率
4. 按综合归档率降序排序

#### 方法2: 获取个人维度概览

```python
def get_persons_archive_overview(self, year_filter=None, project_filter=None):
    """
    获取个人维度的归档概览
    
    Args:
        year_filter: str - 年度筛选
        project_filter: str or None - 项目筛选（影响经办人范围）
    
    Returns:
        dict: {
            'summary': {汇总统计},
            'persons': [{经办人列表}]
        }
    """
```

**实现要点**:
1. 获取所有经办人名单（采购经办人 + 合同经办人）
2. 受`project_filter`影响：只统计在指定项目中有业务的经办人
3. 每个经办人需计算：采购统计、合同统计、负责项目数
4. 按综合归档率或业务量排序

#### 方法3: 获取所有经办人汇总趋势（新增）

```python
def get_all_persons_trend_and_problems(self, year_filter=None, project_filter=None):
    """
    获取所有经办人的汇总趋势图和超期记录（用于个人视图主页面）
    
    Args:
        year_filter: 年度筛选
        project_filter: 项目筛选
    
    Returns:
        dict: {
            'procurement_trend': [...],  # 所有经办人的采购平均周期
            'contract_trend': [...],     # 所有经办人的合同平均周期
            'problems': {...}            # 所有经办人的超期记录汇总
        }
    """
```

**实现要点**:
1. 计算所有经办人的整体平均归档周期趋势
2. 汇总所有经办人的超期记录
3. 数据范围受全局筛选（年度、项目）影响

---

## 四、视图层设计

### 4.1 URL参数设计

```python
# 归档监控页面URL参数
/monitoring/archive/?view_mode=project&target_code=PRJ001&global_year=2024&show_all=false

参数说明:
- view_mode: str - 视图模式（'project' | 'person'）
- target_code: str - 目标编码（项目编码或经办人姓名）
- global_year: str - 全局年度筛选（'all' | '2024' | '2023'）
- global_project: str - 全局项目筛选（项目编码或空）
- show_all: bool - 是否显示所有记录（包括已归档）
```

### 4.2 视图函数逻辑重构

修改 [`archive_monitor()`](project/views.py:2172) 函数：

```python
def archive_monitor(request):
    """归档监控 - 支持项目视图和个人视图"""
    from project.services.monitors.archive_statistics import ArchiveStatisticsService
    
    # 1. 解析全局筛选参数
    global_filters = _resolve_global_filters(request)
    view_mode = request.GET.get('view_mode', 'project')  # 默认项目视图
    target_code = request.GET.get('target_code', '')
    show_all = request.GET.get('show_all', '') == 'true'
    
    # 2. 初始化服务
    stats_service = ArchiveStatisticsService()
    
    # 3. 根据视图模式获取概览数据
    if view_mode == 'project':
        overview_data = stats_service.get_projects_archive_overview(
            year_filter=global_filters['year_value'],
            project_filter=global_filters['project']
        )
    else:  # person
        overview_data = stats_service.get_persons_archive_overview(
            year_filter=global_filters['year_value'],
            project_filter=global_filters['project']
        )
    
    # 4. 如果选择了目标，获取详细数据（趋势图 + 超期记录）
    detail_data = None
    if target_code:
        if view_mode == 'project':
            detail_data = stats_service.get_project_trend_and_problems(
                project_code=target_code,
                year_filter=global_filters['year_value']
            )
        else:
            detail_data = stats_service.get_person_trend_and_problems(
                person_name=target_code,
                year_filter=global_filters['year_value'],
                project_filter=global_filters['project']
            )
    
    # 5. 个人视图下，获取所有经办人的汇总趋势
    all_persons_data = None
    if view_mode == 'person':
        all_persons_data = stats_service.get_all_persons_trend_and_problems(
            year_filter=global_filters['year_value'],
            project_filter=global_filters['project']
        )
    
    # 6. 构建上下文
    context = {
        'page_title': '归档监控',
        'view_mode': view_mode,
        'target_code': target_code,
        'overview_data': 

    # 6. 构建上下文
    context = {
        'page_title': '归档监控',
        'view_mode': view_mode,
        'target_code': target_code,
        'overview_data': overview_data,
        'detail_data': detail_data,
        'all_persons_data': all_persons_data,
        'show_all': show_all,
        'filter_config': filter_config,
    }
    
    return render(request, 'monitoring/archive.html', context)
```

### 4.3 状态管理策略

- **URL作为单一数据源**: 所有状态通过URL参数传递，支持书签和分享
- **无前端状态管理**: 避免前端复杂的状态同步问题
- **刷新即更新**: 切换视图、选择目标后，通过页面跳转更新数据

---

## 五、模板层设计

### 5.1 页面结构设计

```
archive.html 结构:
├── 页面标题和筛选状态提示
├── 视图模式切换器（项目视图 / 个人视图）
├── 目标选择器（项目选择器 / 经办人选择器）
├── 概览数据展示区
│   ├── 汇总统计卡片（4张）
│   └── 数据列表表格
│       ├── 项目列表（项目视图）
│       └── 经办人列表（个人视图）
├── 详情数据展示区（选择目标后显示）
│   ├── 统计卡片（平均周期、及时率）
│   ├── 归档周期趋势图
│   └── 超期记录列表
└── 所有经办人汇总区（个人视图专用）
    ├── 汇总趋势图
    └── 汇总超期记录
```

### 5.2 条件渲染逻辑

```django
{# 1. 视图模式切换器 - 始终显示 #}
<div class="view-mode-selector">
    <button data-mode="project" class="{% if view_mode == 'project' %}active{% endif %}">
        项目视图
    </button>
    <button data-mode="person" class="{% if view_mode == 'person' %}active{% endif %}">
        个人视图
    </button>
</div>

{# 2. 目标选择器 - 根据视图模式显示不同选择器 #}
{% if view_mode == 'project' %}
    <select id="projectSelector">
        <option value="">全部项目</option>
        {# 通过API加载项目列表 #}
    </select>
{% else %}
    <select id="personSelector">
        <option value="">全部经办人</option>
        {% for person in person_list %}
        <option value="{{ person.name }}">{{ person.name }} ({{ person.count }}条)</option>
        {% endfor %}
    </select>
{% endif %}

{# 3. 概览列表 - 根据视图模式显示不同表格 #}
{% if view_mode == 'project' %}
    {# 项目列表表格 #}
    <table>
        <thead>
            <tr>
                <th>项目名称</th>
                <th>采购数量</th>
                <th>采购周期</th>
                <th>合同数量</th>
                <th>合同周期</th>
                <th>综合归档率</th>
                <th>操作</th>
            </tr>
        </thead>
        <tbody>
            {% for project in overview_data.projects %}
            <tr>
                <td>{{ project.project_code }} - {{ project.project_name }}</td>
                <td>{{ project.procurement_archived }}/{{ project.procurement_count }}</td>
                <td>{{ project.procurement_avg_cycle }}天 ({{ project.procurement_on_time_rate }}%)</td>
                <td>{{ project.contract_archived }}/{{ project.contract_count }}</td>
                <td>{{ project.contract_avg_cycle }}天 ({{ project.contract_on_time_rate }}%)</td>
                <td>
                    <div class="progress">
                        <div class="progress-bar" style="width: {{ project.overall_archive_rate }}%">
                            {{ project.overall_archive_rate }}%
                        </div>
                    </div>
                </td>
                <td>
                    <button onclick="viewDetail('{{ project.project_code }}')">查看详情</button>
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
{% else %}
    {# 经办人列表表格 - 结构类似 #}
{% endif %}

{# 4. 详情区域 - 选择了target_code时显示 #}
{% if target_code and detail_data %}
<div class="detail-section">
    {# 4.1 统计卡片 #}
    <div class="stats-cards">
        <div class="card">
            <h6>采购平均归档周期</h6>
            <h2>{{ detail_data.procurement_avg_cycle }} 天</h2>
            <small>及时率：{{ detail_data.procurement_on_time_rate }}%</small>
        </div>
        <div class="card">
            <h6>合同平均归档周期</h6>
            <h2>{{ detail_data.contract_avg_cycle }} 天</h2>
            <small>及时率：{{ detail_data.contract_on_time_rate }}%</small>
        </div>
    </div>
    
    {# 4.2 趋势图 #}
    <div class="trend-chart">
        <canvas id="trendChart"></canvas>
    </div>
    
    {# 4.3 超期记录 #}
    <div class="problems-list">
        {% for severity, items in detail_data.problems.items %}
            {% if items %}
            <div class="problem-group">
                <h6>{{ severity }} ({{ items|length }}条)</h6>
                <table>
                    {# 超期记录表格 #}
                </table>
            </div>
            {% endif %}
        {% endfor %}
    </div>
</div>
{% endif %}

{# 5. 个人视图汇总区 - 仅个人视图下显示 #}
{% if view_mode == 'person' and all_persons_data %}
<div class="all-persons-summary">
    <h5>所有经办人归档周期趋势（汇总）</h5>
    <canvas id="allPersonsTrendChart"></canvas>
    
    <h5>所有经办人超期记录汇总</h5>
    {# 超期记录表格 #}
</div>
{% endif %}
```

### 5.3 Chart.js趋势图配置

```javascript
// 初始化趋势图
function initTrendChart(chartId, trendData) {
    const ctx = document.getElementById(chartId).getContext('2d');
    
    new Chart(ctx, {
        type: 'line',
        data: {
            labels: trendData.map(d => d.period),
            datasets: [
                {
                    label: '采购归档周期',
                    data: trendData.procurement.map(d => d.avg_cycle),
                    borderColor: '#0d6efd',
                    backgroundColor: 'rgba(13, 110, 253, 0.1)',
                    tension: 0.4,
                    spanGaps: true  // 自动跳过null值
                },
                {
                    label: '合同归档周期',
                    data: trendData.contract.map(d => d.avg_cycle),
                    borderColor: '#198754',
                    backgroundColor: 'rgba(25, 135, 84, 0.1)',
                    tension: 0.4,
                    spanGaps: true
                },
                {
                    label: '采购规定周期（40天）',
                    data: Array(trendData.length).fill(40),
                    borderColor: '#0d6efd',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false
                },
                {
                    label: '合同规定周期（30天）',
                    data: Array(trendData.length).fill(30),
                    borderColor: '#198754',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    fill: false
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y + ' 天';
                            }
                            return label;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: '平均归档周期（天）'
                    }
                }
            }
        }
    });
}
```

---

## 六、前端交互设计

### 6.1 视图切换交互

```javascript
// 视图模式切换
document.querySelectorAll('.view-mode-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        const mode = this.dataset.mode;
        const url = new URL(window.location.href);
        url.searchParams.set('view_mode', mode);
        url.searchParams.delete('target_code');  // 切换视图时清除目标选择
        window.location.href = url.toString();
    });
});
```

### 6.2 目标选择交互

```javascript
// 项目/经办人选择
document.getElementById('targetSelect').addEventListener('change', function() {
    const targetCode = this.value;
    const url = new URL(window.location.href);
    if (targetCode) {
        url.searchParams.set('target_code', targetCode);
    } else {
        url.searchParams.delete('target_code');
    }
    window.location.href = url.toString();
});

// "显示所有记录"复选框
document.getElementById('showAllCheck').addEventListener('change', function() {
    const url = new URL(window.location.href);
    if (this.checked) {
        url.searchParams.set('show_all', 'true');
    } else {
        url.searchParams.delete('show_all');
    }
    window.location.href = url.toString();
});
```

### 6.3 项目选择器API集成

```javascript
// 使用Smart Selector组件加载项目列表
const projectSelector = new SmartSelector('#projectSelector', {
    apiUrl: '/api/projects/list/',
    searchEnabled: true,
    placeholder: '搜索项目...',
    valueField: 'project_code',
    displayFormat: (item) => `${item.project_code} - ${item.project_name}`,
    onChange: (selectedValue) => {
        const url = new URL(window.location.href);
        if (selectedValue) {
            url.searchParams.set('target_code', selectedValue);
        } else {
            url.searchParams.delete('target_code');
        }
        window.location.href = url.toString();
    }
});
```

---

## 七、分阶段实施计划

### 阶段1: 服务层开发（3天）

#### 任务1.1: 扩展ArchiveStatisticsService类（1天）

**目标**: 在 [`project/services/monitors/archive_statistics.py`](project/services/monitors/archive_statistics.py:13) 中新增方法

**具体步骤**:

1. **新增`get_projects_archive_overview()`方法** (4小时)
   - 输入参数验证
   - 查询所有项目或指定项目
   - 为每个项目计算采购统计（调用现有`_calculate_procurement_statistics`）
   - 为每个项目计算合同统计（调用现有`_calculate_contract_statistics`）
   - 计算综合归档率
   - 按归档率降序排序
   - 构建返回数据结构

2. **新增`get_persons_archive_overview()`方法** (4小时)
   - 获取所有经办人名单（采购+合同）
   - 应用项目筛选（如果指定）
   - 为每个经办人计算统计数据
   - 计算负责项目数
   - 按业务量或归档率排序
   - 构建返回数据结构

**验证点**:
- ✅ 项目概览方法返回正确的数据结构
- ✅ 个人概览方法返回正确的数据结构
- ✅ 年度筛选正确影响数据范围
- ✅ 项目筛选正确影响数据范围
- ✅ 统计数据计算准确（手动验证几条记录）

#### 任务1.2: 新增经办人汇总方法（1天）

**目标**: 实现个人视图的汇总趋势和超期记录

**具体步骤**:

1. **新增`get_all_persons_trend_and_problems()`方法** (6小时)
   - 获取所有经办人的采购数据（应用年度和项目筛选）
   - 获取所有经办人的合同数据
   - 计算汇总的平均归档周期趋势
   - 调用ArchiveProblemDetector获取超期记录
   - 构建返回数据结构

2. **优化经办人详情方法** (2小时)
   - 完善`get_person_trend_and_problems()`方法
   - 确保支持项目筛选参数
   - 确保返回数据结构一致

**验证点**:
- ✅ 汇总趋势图数据正确计算所有经办人的平均值
- ✅ 超期记录正确汇总所有经办人的数据
- ✅ 全局筛选正确影响汇总数据范围

#### 任务1.3: 编写单元测试（1天）

**测试覆盖**:

```python
# tests/test_archive_statistics.py

class TestArchiveStatisticsService:
    def test_get_projects_overview_all_projects(self):
        """测试获取所有项目概览"""
        service = ArchiveStatisticsService()
        result = service.get_projects_archive_overview(year_filter='2024', project_filter=None)
        
        assert 'summary' in result
        assert 'projects' in result
        assert len(result['projects']) > 0
        assert result['summary']['project_count'] == len(result['projects'])
    
    def test_get_projects_overview_single_project(self):
        """测试获取单个项目概览"""
        # 创建测试数据
        project = Project.objects.create(project_code='TEST001', project_name='测试项目')
        
        service = ArchiveStatisticsService()
        result = service.get_projects_archive_overview(year_filter='2024', project_filter='TEST001')
        
        assert len(result['projects']) == 1
        assert result['projects'][0]['project_code'] == 'TEST001'
    
    def test_get_persons_overview(self):
        """测试获取经办人概览"""
        service = ArchiveStatisticsService()
        result = service.get_persons_archive_overview(year_filter='2024', project_filter=None)
        
        assert 'summary' in result
        assert 'persons' in result
        # 验证经办人数据完整性
        for person in result['persons']:
            assert 
'handler_name' in person
            assert 'overall_archive_rate' in person
            assert 'project_count' in person
    
    def test_trend_data_half_year_grouping(self):
        """测试趋势图半年分组逻辑"""
        # 创建跨年度的测试数据
        # 验证半年分组结果
        pass
    
    def test_trend_data_monthly_grouping(self):
        """测试趋势图月度分组逻辑"""
        # 创建单年度的测试数据
        # 验证月度分组结果
        pass
```

**验证点**:
- ✅ 所有单元测试通过
- ✅ 测试覆盖率 > 80%
- ✅ 边界情况测试（空数据、单条数据等）

---

### 阶段2: 视图层开发（2天）

#### 任务2.1: 重构archive_monitor视图函数（1天）

**文件**: [`project/views.py`](project/views.py:2172)

**具体步骤**:

1. **修改视图函数签名和参数解析** (2小时)
   ```python
   def archive_monitor(request):
       # 解析全局筛选参数
       global_filters = _resolve_global_filters(request)
       view_mode = request.GET.get('view_mode', 'project')
       target_code = request.GET.get('target_code', '')
       show_all = request.GET.get('show_all', '') == 'true'
   ```

2. **实现视图模式分支逻辑** (3小时)
   - 项目视图分支：调用`get_projects_archive_overview()`
   - 个人视图分支：调用`get_persons_archive_overview()`
   - 目标详情分支：根据视图模式调用不同方法
   - 个人汇总分支：调用`get_all_persons_trend_and_problems()`

3. **构建context数据** (2小时)
   - 整合概览数据
   - 整合详情数据
   - 整合筛选配置
   - 将趋势数据转为JSON格式

4. **删除旧代码** (1小时)
   - 移除现有的problem_detector相关代码
   - 清理不再使用的变量

**验证点**:
- ✅ 访问`/monitoring/archive/`显示项目视图
- ✅ 访问`/monitoring/archive/?view_mode=person`显示个人视图
- ✅ 选择项目后显示项目详情
- ✅ 选择经办人后显示经办人详情
- ✅ 全局筛选正确影响数据范围
- ✅ 无报错，控制台无错误信息

#### 任务2.2: 测试视图层功能（1天）

**测试场景**:

| 场景ID | 场景描述 | 预期结果 |
|--------|---------|---------|
| V2.1 | 默认访问页面 | 显示项目视图，展示所有项目列表 |
| V2.2 | 切换到个人视图 | 显示所有经办人列表 |
| V2.3 | 项目视图下选择项目 | 显示该项目的趋势图和超期记录 |
| V2.4 | 个人视图下选择经办人 | 显示该经办人的趋势图和超期记录 |
| V2.5 | 全局筛选2024年 | 所有数据只显示2024年的业务 |
| V2.6 | 全局选择项目A | 项目视图只显示项目A，个人视图只显示在项目A有业务的经办人 |
| V2.7 | 勾选"显示所有记录" | 超期记录中包含已归档记录 |

**验证点**:
- ✅ 所有场景测试通过
- ✅ 数据显示正确
- ✅ 交互逻辑正确

---

### 阶段3: 模板层开发（2天）

#### 任务3.1: 重构archive.html模板（1天）

**文件**: [`project/templates/monitoring/archive.html`](project/templates/monitoring/archive.html:1)

**具体步骤**:

1. **添加视图模式切换器** (1小时)
   - 两个按钮：项目视图、个人视图
   - 根据`view_mode`高亮当前视图
   - 点击触发JavaScript切换

2. **实现目标选择器** (2小时)
   - 项目选择器：使用Smart Selector组件，API加载
   - 经办人选择器：使用普通select，后端传递person_list
   - 根据view_mode条件显示

3. **重构概览列表区域** (2小时)
   - 项目列表表格：7列（项目名称、采购数量、采购周期、合同数量、合同周期、归档率、操作）
   - 经办人列表表格：8列（经办人、采购数量、采购周期、合同数量、合同周期、归档率、负责项目数、操作）
   - 使用{% if view_mode == 'project' %}条件渲染

4. **实现详情展示区域** (2小时)
   - 统计卡片：采购平均周期、合同平均周期
   - 趋势图容器：Canvas元素
   - 超期记录列表：按严重程度分组
   - 使用{% if target_code and detail_data %}条件渲染

5. **添加个人视图汇总区** (1小时)
   - 所有经办人汇总趋势图
   - 所有经办人汇总超期记录
   - 使用{% if view_mode == 'person' and all_persons_data %}条件渲染

**验证点**:
- ✅ 页面结构清晰，布局合理
- ✅ 所有条件渲染正确
- ✅ 数据绑定正确
- ✅ 响应式布局适配移动端

#### 任务3.2: 实现前端交互逻辑（1天）

**文件**: [`project/static/js/archive-statistics.js`](project/static/js/archive-statistics.js:1)

**具体步骤**:

1. **创建ArchiveStatistics类** (2小时)
   ```javascript
   class ArchiveStatistics {
       constructor(options) {
           this.viewMode = options.viewMode;
           this.targetCode = options.targetCode;
           this.trendData = options.trendData;
           this.init();
       }
       
       init() {
           this.bindViewModeSwitch();
           this.bindTargetSelect();
           this.bindShowAllCheckbox();
           if (this.trendData) {
               this.initTrendChart();
           }
       }
       
       bindViewModeSwitch() { /* ... */ }
       bindTargetSelect() { /* ... */ }
       bindShowAllCheckbox() { /* ... */ }
       initTrendChart() { /* ... */ }
   }
   ```

2. **实现趋势图渲染** (3小时)
   - 使用Chart.js 4.x API
   - 实线：采购周期、合同周期
   - 虚线：规定周期基准线
   - spanGaps: true 自动跳过空数据点
   - 鼠标悬停显示详细信息

3. **实现Smart Selector集成** (2小时)
   - 项目选择器API调用`/api/projects/list/`
   - 支持搜索、分页
   - onChange事件触发页面跳转

4. **优化用户体验** (1小时)
   - 加载状态提示
   - 错误处理
   - 平滑过渡动画

**验证点**:
- ✅ 视图切换流畅
- ✅ 目标选择立即生效
- ✅ 趋势图正确渲染
- ✅ 图表交互正常（鼠标悬停、缩放等）
- ✅ 无JavaScript错误

---

### 阶段4: 测试与优化（2天）

#### 任务4.1: 功能测试（1天）

**测试矩阵**:

| 功能模块 | 测试用例 | 验证点 |
|---------|---------|-------|
| 视图切换 | 项目视图 ↔ 个人视图 | URL参数正确，数据正确切换 |
| 项目选择 | 选择具体项目 | 显示项目详情，趋势图和超期记录 |
| 经办人选择 | 选择具体经办人 | 显示经办人详情，趋势图和超期记录 |
| 全局年度筛选 | 2024年 / 全部年度 | 数据范围正确 |
| 全局项目筛选 | 项目A / 全部项目 | 项目视图和个人视图数据范围正确 |
| 趋势图-全年度 | year_filter='all' | 按半年分组，正确显示 |
| 趋势图-单年度 | year_filter='2024' | 按月分组，正确显示 |
| 超期记录 | 严重/中度/轻微 | 分级正确，数据准确 |
| 显示所有记录 | 勾选/取消 | 包含/排除已归档记录 |

**验证步骤**:
1. 创建测试数据（至少3个项目，5个经办人，20条采购，30条合同）
2. 逐一执行测试用例
3. 记录测试结果
4. 修复发现的问题

#### 任务4.2: 性能优化（0.5天）

**优化目标**:
- 页面首次加载时间 < 2秒
- 查看详情响应时间 < 1秒
- 大数据量（100+项目）下流畅

**优化措施**:

1. **数据库查询优化**
   - 使用`select_related()`预加载关联
   - 使用`annotate()`在数据库层计算
   - 添加数据库索引（如需要）

2. **前端性能优化**
   - Chart.js图表使用`animation: {duration: 0}`加快首次渲染
   - 表格使用分页（如数据量大）
   - 图片懒加载

3. **缓存策略**
   - 静态资源添加版本号
   - 考虑使用Django缓存框架（可选）

**验证点**:
- ✅ 使用Django Debug Toolbar检查SQL查询数量
- ✅ 使用Chrome DevTools检查页面加载时间
- ✅ 大数据量测试（创建100个项目）

#### 任务4.3: 浏览器兼容性测试（0.5天）

**测试浏览器**:
- Chrome 最新版 ✅
- Firefox 最新版 ✅
- Edge 最新版 ✅
- Safari 最新版（如有Mac） ✅

**测试内容**:
- 页面布局
- Chart.js图表渲染
- JavaScript交互
- CSS动画效果

---

## 八、验收测试标准

### 8.1 功能验收清单

#### 基础功能（必须）

- [ ] **F1**: 默认显示项目视图，展示所有项目列表
- [ ] **F2**: 点击"个人视图"切换到经办人列表
- [ ] **F3**: 项目视图下，选择具体项目后显示该项目的趋势图和超期记录
- [ ] **F4**: 个人视图下，选择具体经办人后显示该经办人的趋势图和超期记录
- [ ] **F5**: 个人视图下，始终显示所有经办人的汇总趋势图和超期记录
- [ ] **F6**: 全局年度筛选正确影响数据范围
- [ ] **F7**: 全局项目筛选在项目视图下正确过滤项目列表
- [ ] **F8**: 全局项目筛选在个人视图下正确过滤经办人范围
- [ ] **F9**: 趋势图在全年度模式下按半年分组
- [ ] **F10**: 趋势图在单年度模式下按月分组
- [ ] **F11**: 趋势图正确显示采购周期、合同周期和基准线
- [ ] **F12**: 趋势图自动跳过无数据的时间点
- [ ] **F13**: 超期记录按严重程度正确分组
- [ ] **F14**: "显示所有记录"复选框正确控制数据范围

#### 数据准确性（必须）

- [ ] **D1**: 采购平均归档周期计算正确
- [ ] **D2**: 合同平均归档周期计算正确
- [ ] **D3**: 采购及时率计算正确（≤40天）
- [ ] **D4**: 合同及时率计算正确（≤30天）
- [ ] **D5**: 综合归档率计算正确
- [ ] **D6**: 项目列表数量统计准确
- [ ] **D7**: 经办人列表数量统计准确
- [ ] **D8**: 负责项目数统计准确
- [ ] **D9**: 趋势图数据点准确
- [ ] **D10**: 超期天数计算准确

#### 
用户体验（必须）

- [ ] **U1**: 界面布局清晰，信息层次分明
- [ ] **U2**: 交互流程顺畅，无需多次点击
- [ ] **U3**: 响应式设计良好，适配不同屏幕
- [ ] **U4**: 数据展示直观，易于理解
- [ ] **U5**: 加载状态有明确提示
- [ ] **U6**: 错误信息友好易懂

### 8.2 性能验收标准

| 指标 | 目标值 | 测试方法 |
|------|--------|---------|
| 页面首次加载时间 | < 2秒 | Chrome DevTools Network |
| 查看详情响应时间 | < 1秒 | Chrome DevTools Network |
| SQL查询数量 | < 10个 | Django Debug Toolbar |
| 趋势图渲染时间 | < 500ms | Console.time() |
| 大数据量（100+项目）渲染 | 流畅无卡顿 | 实际测试 |

### 8.3 兼容性验收标准

- [ ] Chrome 最新版正常运行
- [ ] Firefox 最新版正常运行
- [ ] Edge 最新版正常运行
- [ ] Safari 最新版正常运行（如有条件）
- [ ] 移动端浏览器基本可用

### 8.4 数据验收方法

**采样验证法**：
1. 随机选择5个项目，手动计算其统计数据
2. 与系统显示数据对比，误差 < 1%
3. 随机选择5个经办人，同样方法验证
4. 抽查10条超期记录，验证逾期天数计算

**边界测试**：
- 无数据项目：显示0天，0%
- 单条数据项目：正确显示单条数据的周期
- 跨年度项目：趋势图正确显示多个半年数据

---

## 九、风险评估与应对

### 9.1 技术风险

#### 风险1: 数据量大导致性能问题

**风险等级**: 中等

**影响**: 页面加载缓慢，用户体验差

**应对措施**:
1. 优先级1：数据库查询优化，使用索引和聚合
2. 优先级2：添加分页功能（如项目列表超过50个）
3. 优先级3：考虑使用缓存（Redis）缓存概览数据

**监控指标**: 
- SQL查询数量 < 10
- 页面加载时间 < 2秒

#### 风险2: 趋势图数据复杂导致前端渲染慢

**风险等级**: 低

**影响**: 图表渲染延迟

**应对措施**:
1. 使用Chart.js的性能优化配置（decimation、spanGaps）
2. 限制数据点数量（最多24个月或10个半年）
3. 使用requestAnimationFrame优化动画

**监控指标**:
- 趋势图渲染时间 < 500ms

#### 风险3: 经办人数据不一致

**风险等级**: 中等

**影响**: 统计数据不准确

**应对措施**:
1. 数据验证：在导入时规范经办人姓名格式
2. 数据清洗：提供管理工具合并重复经办人
3. 容错处理：经办人为空时使用"未指定"标记

**监控指标**:
- 经办人名称一致性检查报告

### 9.2 业务风险

#### 风险4: 用户不理解新的视图模式

**风险等级**: 中等

**影响**: 用户困惑，无法有效使用功能

**应对措施**:
1. 提供页面内帮助提示（工具提示）
2. 编写用户手册或操作视频
3. 上线前组织培训或演示

**监控指标**:
- 用户反馈满意度 > 80%

#### 风险5: 数据计算逻辑与用户预期不符

**风险等级**: 高

**影响**: 用户质疑数据准确性

**应对措施**:
1. 上线前与用户确认计算逻辑
2. 提供数据计算说明文档
3. 提供数据导出功能，便于用户验证

**监控指标**:
- 数据准确性投诉 = 0

### 9.3 项目风险

#### 风险6: 开发时间超预期

**风险等级**: 中等

**影响**: 无法按期上线

**应对措施**:
1. 采用分阶段实施，优先保证核心功能
2. 可选功能放入后续迭代（如详情模态框）
3. 每日进度跟踪，及时调整计划

**关键路径**:
- 服务层开发 → 视图层开发 → 模板层开发 → 测试

#### 风险7: 现有功能破坏

**风险等级**: 低

**影响**: 影响其他监控页面

**应对措施**:
1. 仅修改archive_monitor视图，不影响其他视图
2. 保持ArchiveStatisticsService向后兼容
3. 充分的回归测试

**监控指标**:
- 其他监控页面功能正常

---

## 十、实施时间表

### 总体时间安排（9个工作日）

```
Week 1: 服务层和视图层开发
┌─────────────────────────────────────────────────┐
│ Day 1-3: 服务层开发                             │
│   ├─ Day 1: 新增概览方法                        │
│   ├─ Day 2: 新增汇总方法                        │
│   └─ Day 3: 单元测试                            │
├─────────────────────────────────────────────────┤
│ Day 4-5: 视图层开发                             │
│   ├─ Day 4: 重构视图函数                        │
│   └─ Day 5: 视图层测试                          │
└─────────────────────────────────────────────────┘

Week 2: 模板层和测试优化
┌─────────────────────────────────────────────────┐
│ Day 6-7: 模板层开发                             │
│   ├─ Day 6: 重构HTML模板                        │
│   └─ Day 7: JavaScript交互                      │
├─────────────────────────────────────────────────┤
│ Day 8-9: 测试与优化                             │
│   ├─ Day 8: 功能测试 + 性能优化                 │
│   └─ Day 9: 浏览器兼容性测试 + Bug修复          │
└─────────────────────────────────────────────────┘
```

### 每日详细计划

#### Day 1: 服务层-概览方法开发
- 09:00-12:00: 实现`get_projects_archive_overview()`
- 13:30-17:00: 实现`get_persons_archive_overview()`
- 17:00-18:00: 代码审查和优化

**交付物**: ✅ 两个新方法实现并能正常调用

#### Day 2: 服务层-汇总方法开发
- 09:00-12:00: 实现`get_all_persons_trend_and_problems()`
- 13:30-16:00: 优化`get_person_trend_and_problems()`
- 16:00-18:00: 方法集成测试

**交付物**: ✅ 所有服务层方法完成

#### Day 3: 服务层-单元测试
- 09:00-12:00: 编写项目概览测试
- 13:30-16:00: 编写个人概览测试
- 16:00-18:00: 边界测试和覆盖率检查

**交付物**: ✅ 单元测试通过，覆盖率>80%

#### Day 4: 视图层-重构视图函数
- 09:00-11:00: 参数解析和视图模式分支
- 11:00-13:00: 数据获取和context构建
- 14:00-16:00: 删除旧代码和清理
- 16:00-18:00: 手动测试和调试

**交付物**: ✅ 视图函数重构完成，基本可用

#### Day 5: 视图层-功能测试
- 09:00-12:00: 执行测试矩阵（V2.1-V2.7）
- 13:30-16:00: 修复发现的问题
- 16:00-18:00: 回归测试

**交付物**: ✅ 所有视图层测试通过

#### Day 6: 模板层-HTML重构
- 09:00-12:00: 视图切换器和选择器
- 13:30-15:30: 概览列表区域
- 15:30-17:30: 详情展示区域
- 17:30-18:00: 样式调整

**交付物**: ✅ HTML模板重构完成

#### Day 7: 模板层-JavaScript实现
- 09:00-11:00: ArchiveStatistics类实现
- 11:00-14:00: 趋势图渲染
- 14:00-16:00: Smart Selector集成
- 16:00-18:00: 交互优化和错误处理

**交付物**: ✅ 前端交互完整实现

#### Day 8: 测试与性能优化
- 09:00-12:00: 功能测试矩阵执行
- 13:30-15:30: 性能优化（SQL、前端）
- 15:30-17:30: 大数据量测试
- 17:30-18:00: 性能验收

**交付物**: ✅ 性能指标达标

#### Day 9: 兼容性测试和Bug修复
- 09:00-12:00: 多浏览器测试
- 13:30-16:00: Bug修复
- 16:00-17:30: 最终回归测试
- 17:30-18:00: 文档更新和交付准备

**交付物**: ✅ 功能完整，测试通过，可上线

---

## 十一、交付清单

### 代码文件

- [x] [`project/services/monitors/archive_statistics.py`](project/services/monitors/archive_statistics.py) - 服务层扩展
- [x] [`project/views.py`](project/views.py) - 视图层重构
- [x] [`project/templates/monitoring/archive.html`](project/templates/monitoring/archive.html) - 模板层重构
- [x] [`project/static/js/archive-statistics.js`](project/static/js/archive-statistics.js) - 前端交互
- [x] `tests/test_archive_statistics.py` - 单元测试

### 文档文件

- [x] 本技术方案文档
- [x] 用户操作手册（可选）
- [x] API接口文档（如有新增）
- [x] 数据计算说明文档

### 测试报告

- [x] 单元测试报告
- [x] 功能测试报告
- [x] 性能测试报告
- [x] 兼容性测试报告

---

## 十二、后续优化建议

### 短期优化（1-2周内）

1. **添加数据导出功能**: 支持导出概览列表为Excel
2. **优化移动端体验**: 响应式表格，适配小屏幕
3. **添加数据缓存**: 使用Redis缓存概览数据，提升性能

### 中期优化（1-2月内）

1. **详情模态框**: 点击查看详情使用模态框而非页面展开
2. **经办人数据管理**: 提供经办人合并和规范工具
3. **自定义报表**: 支持用户自定义统计维度

### 长期规划（3-6月内）

1. **实时数据更新**: 使用WebSocket实现数据实时刷新
2. **智能预警**: 基于历史数据预测归档逾期风险
3. **数据可视化增强**: 添加更多图表类型（饼图、雷达图等）

---

## 十三、附录

### A. 数据模型关系图

```
Project (项目)
  ├─→ Procurement (采购)
  │     └─ 
字段:
  │       ├─ procurement_officer (经办人)
  │       ├─ result_publicity_release_date (业务日期)
  │       └─ archive_date (归档日期)
  └─→ Contract (合同)
        └─ 字段:
            ├─ contract_officer (经办人)
            ├─ signing_date (业务日期)
            └─ archive_date (归档日期)
```

### B. 关键计算公式

#### 归档周期计算

```python
# 采购归档周期
procurement_cycle = archive_date - result_publicity_release_date  # 天数

# 合同归档周期
contract_cycle = archive_date - signing_date  # 天数
```

#### 平均周期计算

```python
# 采购平均周期
avg_procurement_cycle = SUM(procurement_cycle) / COUNT(已归档采购)

# 合同平均周期
avg_contract_cycle = SUM(contract_cycle) / COUNT(已归档合同)
```

#### 及时率计算

```python
# 采购及时率（规定40天）
procurement_on_time_rate = COUNT(cycle <= 40天) / COUNT(已归档采购) × 100%

# 合同及时率（规定30天）
contract_on_time_rate = COUNT(cycle <= 30天) / COUNT(已归档合同) × 100%
```

#### 综合归档率计算

```python
# 综合归档率
overall_archive_rate = (采购已归档数 + 合同已归档数) / (采购总数 + 合同总数) × 100%
```

### C. URL参数示例

```
# 默认访问（项目视图，全部项目）
/monitoring/archive/

# 项目视图，选择项目A
/monitoring/archive/?view_mode=project&target_code=PRJ001

# 个人视图，选择经办人张三
/monitoring/archive/?view_mode=person&target_code=张三

# 全局筛选2024年和项目A
/monitoring/archive/?global_year=2024&global_project=PRJ001

# 显示所有记录（包括已归档）
/monitoring/archive/?view_mode=project&target_code=PRJ001&show_all=true
```

### D. 常见问题FAQ

#### Q1: 为什么个人视图下趋势图显示的是所有经办人的汇总数据？

**A**: 根据需求文档，个人视图主要展示经办人列表，趋势图显示的是所有经办人的整体表现。如果需要查看单个经办人的趋势，可以点击"查看详情"按钮。

#### Q2: 如果项目没有归档数据，平均周期显示什么？

**A**: 显示"0天"，及时率显示"N/A"或"0%"，并在工具提示中说明"暂无归档数据"。

#### Q3: 趋势图中某个时间点没有数据会怎样显示？

**A**: Chart.js的`spanGaps: true`配置会自动跳过该点，折线会连接前后有数据的点，不会断开。

#### Q4: 全局项目筛选在个人视图下的作用是什么？

**A**: 会筛选出在该项目中有业务的经办人，只展示这些经办人的数据。

#### Q5: 如何验证统计数据的准确性？

**A**: 可以导出原始数据，使用Excel手动计算对比。系统也提供数据明细查看功能。

---

## 十四、总结

本技术方案详细规划了归档监控页面的改造工作，核心要点如下：

### 关键设计决策

1. **视图模式分离**: 项目视图和个人视图使用相同页面，通过URL参数切换
2. **服务层扩展**: 基于现有`ArchiveStatisticsService`扩展，保持向后兼容
3. **URL作为单一数据源**: 所有状态通过URL传递，无前端复杂状态管理
4. **数据库层计算**: 最大化利用Django ORM聚合功能，减少Python层计算
5. **渐进增强**: 优先保证核心功能，可选功能后续迭代

### 技术亮点

- ✅ **性能优化**: 使用`select_related`和`annotate`避免N+1查询
- ✅ **用户体验**: 清晰的视图切换，直观的数据展示
- ✅ **可扩展性**: 服务层方法设计支持未来功能扩展
- ✅ **可测试性**: 完整的单元测试和功能测试覆盖
- ✅ **可维护性**: 代码结构清晰，文档完善

### 实施保障

- **9个工作日**的详细时间表
- **每日交付物**明确，便于进度跟踪
- **分阶段验收**，每阶段有明确验证点
- **风险评估**和应对措施完备
- **测试标准**详细，覆盖功能、性能、兼容性

### 预期成果

完成本次改造后，归档监控页面将实现：

1. **双维度统计**: 支持项目维度和个人维度的归档数据分析
2. **直观可视化**: 趋势图清晰展示归档周期变化
3. **精准问题定位**: 超期记录分级展示，便于快速处理
4. **灵活筛选**: 全局筛选和视图筛选结合，满足多样需求
5. **高性能**: 页面加载快速，大数据量下依然流畅

---

## 审核建议

在开始实施前，建议：

1. **需求确认**: 与用户再次确认项目视图和个人视图的具体需求
2. **数据验证**: 检查现有数据的完整性和一致性
3. **技术评审**: 团队评审本技术方案，提出改进建议
4. **资源准备**: 确保开发环境、测试数据、测试工具就绪
5. **时间协调**: 确认9个工作日的时间安排可行

---

**文档状态**: ✅ 完成，待审核批准

**下一步行动**: 
1. 召开技术方案评审会
2. 获得批准后进入实施阶段
3. 按照日计划执行开发任务

---

*本文档最后更新: 2025-01-10*