"""
Service logic for the update monitoring dashboard.

Collects module-specific business events, evaluates deadline compliance (by the
end of the following month), and returns KPI, heatmap, and statistics payloads
for presentation.
"""
from __future__ import annotations

import calendar
from collections import defaultdict
from datetime import date
from typing import Any, Dict, Iterable, List, Optional, Tuple

from django.db.models import QuerySet
from django.utils import timezone

from contract.models import Contract
from payment.models import Payment
from procurement.models import Procurement
from settlement.models import Settlement


class UpdateMonitorService:
    """事件驱动的数据更新监控服务。"""

    MODULES: Dict[str, Dict[str, Any]] = {
        "procurement": {
            "display_name": "采购",
            "model": Procurement,
            "event_field": "result_publicity_release_date",
            "project_path": "project",
            "handler_fields": ["procurement_officer", "updated_by", "created_by"],
            "code_field": "procurement_code",
            "update_attr": "updated_at",
            "fallback_update_attr": "created_at",
        },
        "contract": {
            "display_name": "合同",
            "model": Contract,
            "event_field": "signing_date",
            "project_path": "project",
            "handler_fields": ["contract_officer", "updated_by", "created_by"],
            "code_field": "contract_code",
            "update_attr": "updated_at",
            "fallback_update_attr": "created_at",
        },
        "payment": {
            "display_name": "付款",
            "model": Payment,
            "event_field": "payment_date",
            "project_path": "contract__project",
            "handler_fields": ["updated_by", "created_by"],
            "code_field": "payment_code",
            "update_attr": "updated_at",
            "fallback_update_attr": "created_at",
        },
        "settlement": {
            "display_name": "结算",
            "model": Settlement,
            "event_field": "completion_date",
            "project_path": "main_contract__project",
            "handler_fields": ["updated_by", "created_by"],
            "code_field": "settlement_code",
            "update_attr": "updated_at",
            "fallback_update_attr": "created_at",
        },
    }

    def build_snapshot(self, year: Optional[int], start_date: date) -> Dict[str, Any]:
        """
        构建指定年份与监控起始日期下的监控数据快照。

        Args:
            year: 统计年份；为 None 时统计全部年份。
            start_date: 监控起始日期，早于该日期的业务不计入统计。

        Returns:
            包含 KPI、项目热力图数据、统计表等内容的字典。
        """
        events = self._collect_events(year=year, start_date=start_date)
        payload = self._build_payload(events)
        payload["meta"] = {
            "year": year,
            "startDate": start_date.isoformat(),
            "generatedAt": timezone.now().isoformat(),
        }
        payload["moduleDefinitions"] = [
            {"key": key, "name": config["display_name"]}
            for key, config in self.MODULES.items()
        ]
        payload["statistics"]["moduleKeys"] = list(self.MODULES.keys()) + ["total"]
        return payload

    # ------------------------------------------------------------------ #
    # 数据采集
    # ------------------------------------------------------------------ #

    def _collect_events(self, year: Optional[int], start_date: date) -> List[Dict[str, Any]]:
        events: List[Dict[str, Any]] = []
        for module_key, config in self.MODULES.items():
            queryset = self._build_queryset(config, year, start_date)

            for record in queryset:
                project = self._resolve_attr(record, config["project_path"])
                if project is None:
                    continue

                event_date = getattr(record, config["event_field"], None)
                if event_date is None:
                    continue

                update_datetime = getattr(record, config.get("update_attr", "updated_at"), None)
                if update_datetime is None:
                    fallback_attr = config.get("fallback_update_attr")
                    if fallback_attr:
                        update_datetime = getattr(record, fallback_attr, None)
                if update_datetime is None:
                    continue
                update_date = update_datetime.date()

                handler = self._extract_first_non_empty(record, config.get("handler_fields", []))
                if not handler:
                    handler = "未标记"

                code_value = self._resolve_attr(record, config.get("code_field", "")) or getattr(
                    record, "pk", ""
                )

                deadline = self._calculate_deadline(event_date)
                is_timely = update_date <= deadline

                events.append(
                    {
                        "project_id": project.id,
                        "project_code": project.project_code,
                        "project_name": project.project_name,
                        "module_key": module_key,
                        "module_name": config["display_name"],
                        "event_date": event_date,
                        "update_date": update_date,
                        "handler": handler,
                        "code": str(code_value),
                        "deadline": deadline,
                        "is_timely": is_timely,
                        "month": event_date.month,
                    }
                )
        return events

    def _build_queryset(
        self,
        config: Dict[str, Any],
        year: Optional[int],
        start_date: date,
    ) -> QuerySet:
        model = config["model"]
        event_field = config["event_field"]

        filters = {f"{event_field}__isnull": False}
        if year is not None:
            filters[f"{event_field}__year"] = year
        queryset = model.objects.filter(**filters)
        if start_date:
            queryset = queryset.filter(**{f"{event_field}__gte": start_date})

        related_paths = config.get("select_related")
        if related_paths:
            queryset = queryset.select_related(*related_paths)
        else:
            related_parts = [
                "__".join(config["project_path"].split("__")[: idx + 1])
                for idx in range(len(config["project_path"].split("__")))
            ]
            queryset = queryset.select_related(*related_parts)

        return queryset.order_by(event_field)

    # ------------------------------------------------------------------ #
    # 数据整理
    # ------------------------------------------------------------------ #

    def _build_payload(self, events: Iterable[Dict[str, Any]]) -> Dict[str, Any]:
        projects_map: Dict[int, Dict[str, Any]] = {}
        stats_by_project: Dict[str, Dict[str, Dict[str, int]]] = defaultdict(self._empty_stats_row)
        stats_by_person: Dict[str, Dict[str, Dict[str, int]]] = defaultdict(self._empty_stats_row)

        total_events = 0
        timely_events = 0

        for event in events:
            total_events += 1
            if event["is_timely"]:
                timely_events += 1

            project_entry = projects_map.setdefault(
                event["project_id"], self._init_project_entry(event)
            )
            self._append_event_to_project(project_entry, event)

            project_label = self._format_project_label(event["project_name"], event["project_code"])
            self._bump_stats(stats_by_project[project_label], event)
            self._bump_stats(stats_by_person[event["handler"]], event)

        projects = [
            self._finalize_project_entry(project_entry)
            for project_entry in sorted(
                projects_map.values(), key=lambda item: item["projectName"]
            )
        ]

        kpis = {
            "totalProjects": len(projects),
            "totalEvents": total_events,
            "delayedEvents": total_events - timely_events,
            "overallTimelinessRate": self._safe_rate(timely_events, total_events),
        }

        statistics = {
            "byProject": {label: stats for label, stats in sorted(stats_by_project.items())},
            "byPerson": {label: stats for label, stats in sorted(stats_by_person.items())},
        }

        return {"kpis": kpis, "projects": projects, "statistics": statistics}

    def _init_project_entry(self, event: Dict[str, Any]) -> Dict[str, Any]:
        modules = {
            key: {
                "moduleKey": key,
                "moduleName": config["display_name"],
                "totalEvents": 0,
                "totalTimely": 0,
                "months": {month: {"timely": 0, "delayed": 0, "events": []} for month in range(1, 13)},
            }
            for key, config in self.MODULES.items()
        }
        return {
            "projectId": event["project_id"],
            "projectCode": event["project_code"],
            "projectName": event["project_name"],
            "modules": modules,
            "timelyEvents": 0,
            "totalEvents": 0,
        }

    def _append_event_to_project(self, project_entry: Dict[str, Any], event: Dict[str, Any]) -> None:
        module_entry = project_entry["modules"][event["module_key"]]
        month_bucket = module_entry["months"][event["month"]]
        month_bucket["events"].append(event)

        if event["is_timely"]:
            month_bucket["timely"] += 1
            module_entry["totalTimely"] += 1
            project_entry["timelyEvents"] += 1
        else:
            month_bucket["delayed"] += 1

        module_entry["totalEvents"] += 1
        project_entry["totalEvents"] += 1

    def _finalize_project_entry(self, project_entry: Dict[str, Any]) -> Dict[str, Any]:
        modules_output: List[Dict[str, Any]] = []
        for module_key in self.MODULES.keys():
            module_data = project_entry["modules"][module_key]
            months_output = []
            for month in range(1, 13):
                bucket = module_data["months"][month]
                status, timely_ratio = self._derive_status(bucket["timely"], bucket["delayed"])
                months_output.append(
                    {
                        "month": month,
                        "status": status,
                        "timely": bucket["timely"],
                        "delayed": bucket["delayed"],
                        "timelyRatio": timely_ratio,
                        "events": [
                            {
                                "code": ev["code"],
                                "eventDate": ev["event_date"].isoformat(),
                                "updateDate": ev["update_date"].isoformat(),
                                "deadlineDate": ev["deadline"].isoformat(),
                                "handler": ev["handler"],
                                "isTimely": ev["is_timely"],
                            }
                            for ev in bucket["events"]
                        ],
                    }
                )
            modules_output.append(
                {
                    "moduleKey": module_data["moduleKey"],
                    "moduleName": module_data["moduleName"],
                    "totalEvents": module_data["totalEvents"],
                    "totalTimely": module_data["totalTimely"],
                    "months": months_output,
                }
            )

        return {
            "projectId": project_entry["projectId"],
            "projectCode": project_entry["projectCode"],
            "projectName": project_entry["projectName"],
            "timelyEvents": project_entry["timelyEvents"],
            "totalEvents": project_entry["totalEvents"],
            "timelinessRate": self._safe_rate(project_entry["timelyEvents"], project_entry["totalEvents"]),
            "modules": modules_output,
        }

    def _bump_stats(self, cell_map: Dict[str, Dict[str, int]], event: Dict[str, Any]) -> None:
        module_key = event["module_key"]
        row_cell = cell_map.setdefault(module_key, self._empty_stat_cell())
        total_cell = cell_map.setdefault("total", self._empty_stat_cell())

        for target in (row_cell, total_cell):
            target["total"] += 1
            if event["is_timely"]:
                target["timely"] += 1
            else:
                target["delayed"] += 1

    # ------------------------------------------------------------------ #
    # 工具函数
    # ------------------------------------------------------------------ #

    def _calculate_deadline(self, event_date: date) -> date:
        next_month = event_date.month + 1
        year = event_date.year
        if next_month == 13:
            next_month = 1
            year += 1
        last_day = calendar.monthrange(year, next_month)[1]
        return date(year, next_month, last_day)

    def _resolve_attr(self, instance: Any, path: str) -> Any:
        value = instance
        for attr in filter(None, path.split("__")):
            value = getattr(value, attr, None)
            if value is None:
                return None
        return value

    def _extract_first_non_empty(self, instance: Any, fields: Iterable[str]) -> str:
        for field in fields:
            value = self._resolve_attr(instance, field) if "__" in field else getattr(instance, field, "")
            if isinstance(value, str):
                value = value.strip()
            if value:
                return str(value)
        return ""

    def _derive_status(self, timely_count: int, delayed_count: int) -> Tuple[str, float]:
        total = timely_count + delayed_count
        if total == 0:
            return "no-event", 0.0
        if delayed_count == 0:
            return "on-time", 100.0
        if timely_count == 0:
            return "delayed", 0.0
        ratio = (timely_count / total) * 100
        return "mixed", round(ratio, 1)

    def _safe_rate(self, numerator: int, denominator: int) -> Optional[float]:
        if denominator == 0:
            return None
        return round((numerator / denominator) * 100, 1)

    def _format_project_label(self, name: str, code: str) -> str:
        return f"{name}（{code}）" if code else name

    def _empty_stat_cell(self) -> Dict[str, int]:
        return {"timely": 0, "delayed": 0, "total": 0}

    def _empty_stats_row(self) -> Dict[str, Dict[str, int]]:
        return {}

